// Package quicknode provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package quicknode

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	Api_keyScopes     = "api_key.Scopes"
	Bearer_authScopes = "bearer_auth.Scopes"
)

// Defines values for CreateMethodRateLimitJSONBodyInterval.
const (
	CreateMethodRateLimitJSONBodyIntervalDay    CreateMethodRateLimitJSONBodyInterval = "day"
	CreateMethodRateLimitJSONBodyIntervalMinute CreateMethodRateLimitJSONBodyInterval = "minute"
	CreateMethodRateLimitJSONBodyIntervalSecond CreateMethodRateLimitJSONBodyInterval = "second"
)

// Defines values for UpdateMethodRateLimitJSONBodyStatus.
const (
	UpdateMethodRateLimitJSONBodyStatusDisabled UpdateMethodRateLimitJSONBodyStatus = "disabled"
	UpdateMethodRateLimitJSONBodyStatusEnabled  UpdateMethodRateLimitJSONBodyStatus = "enabled"
)

// Defines values for FetchEndpointMetricParamsPeriod.
const (
	FetchEndpointMetricParamsPeriodDay   FetchEndpointMetricParamsPeriod = "day"
	FetchEndpointMetricParamsPeriodHour  FetchEndpointMetricParamsPeriod = "hour"
	FetchEndpointMetricParamsPeriodMonth FetchEndpointMetricParamsPeriod = "month"
	FetchEndpointMetricParamsPeriodWeek  FetchEndpointMetricParamsPeriod = "week"
)

// Defines values for FetchEndpointMetricParamsMetric.
const (
	FetchEndpointMetricParamsMetricMethodCallBreakdown        FetchEndpointMetricParamsMetric = "method_call_breakdown"
	FetchEndpointMetricParamsMetricMethodCallsOverTime        FetchEndpointMetricParamsMetric = "method_calls_over_time"
	FetchEndpointMetricParamsMetricMethodResponseTimeMax      FetchEndpointMetricParamsMetric = "method_response_time_max"
	FetchEndpointMetricParamsMetricRequestErrorsOverTime      FetchEndpointMetricParamsMetric = "request_errors_over_time"
	FetchEndpointMetricParamsMetricResponseStatusBreakdown    FetchEndpointMetricParamsMetric = "response_status_breakdown"
	FetchEndpointMetricParamsMetricResponseStatusOverTime     FetchEndpointMetricParamsMetric = "response_status_over_time"
	FetchEndpointMetricParamsMetricTotalRequestErrorsOverTime FetchEndpointMetricParamsMetric = "total_request_errors_over_time"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsCors.
const (
	UpdateSecurityOptionsJSONBodyOptionsCorsDisabled UpdateSecurityOptionsJSONBodyOptionsCors = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsCorsEnabled  UpdateSecurityOptionsJSONBodyOptionsCors = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsDomainMasks.
const (
	UpdateSecurityOptionsJSONBodyOptionsDomainMasksDisabled UpdateSecurityOptionsJSONBodyOptionsDomainMasks = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsDomainMasksEnabled  UpdateSecurityOptionsJSONBodyOptionsDomainMasks = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsHsts.
const (
	UpdateSecurityOptionsJSONBodyOptionsHstsDisabled UpdateSecurityOptionsJSONBodyOptionsHsts = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsHstsEnabled  UpdateSecurityOptionsJSONBodyOptionsHsts = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsIpCustomHeader.
const (
	UpdateSecurityOptionsJSONBodyOptionsIpCustomHeaderDisabled UpdateSecurityOptionsJSONBodyOptionsIpCustomHeader = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsIpCustomHeaderEnabled  UpdateSecurityOptionsJSONBodyOptionsIpCustomHeader = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsIps.
const (
	UpdateSecurityOptionsJSONBodyOptionsIpsDisabled UpdateSecurityOptionsJSONBodyOptionsIps = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsIpsEnabled  UpdateSecurityOptionsJSONBodyOptionsIps = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsJwts.
const (
	UpdateSecurityOptionsJSONBodyOptionsJwtsDisabled UpdateSecurityOptionsJSONBodyOptionsJwts = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsJwtsEnabled  UpdateSecurityOptionsJSONBodyOptionsJwts = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsReferrers.
const (
	UpdateSecurityOptionsJSONBodyOptionsReferrersDisabled UpdateSecurityOptionsJSONBodyOptionsReferrers = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsReferrersEnabled  UpdateSecurityOptionsJSONBodyOptionsReferrers = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsRequestFilters.
const (
	UpdateSecurityOptionsJSONBodyOptionsRequestFiltersDisabled UpdateSecurityOptionsJSONBodyOptionsRequestFilters = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsRequestFiltersEnabled  UpdateSecurityOptionsJSONBodyOptionsRequestFilters = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsTokens.
const (
	UpdateSecurityOptionsJSONBodyOptionsTokensDisabled UpdateSecurityOptionsJSONBodyOptionsTokens = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsTokensEnabled  UpdateSecurityOptionsJSONBodyOptionsTokens = "enabled"
)

// Defines values for UpdateEndpointStatusJSONBodyStatus.
const (
	Active UpdateEndpointStatusJSONBodyStatus = "active"
	Paused UpdateEndpointStatusJSONBodyStatus = "paused"
)

// Defines values for FetchAccountMetricsParamsPeriod.
const (
	Day   FetchAccountMetricsParamsPeriod = "day"
	Hour  FetchAccountMetricsParamsPeriod = "hour"
	Month FetchAccountMetricsParamsPeriod = "month"
	Week  FetchAccountMetricsParamsPeriod = "week"
)

// Defines values for FetchAccountMetricsParamsMetric.
const (
	FetchAccountMetricsParamsMetricMethodCallBreakdown        FetchAccountMetricsParamsMetric = "method_call_breakdown"
	FetchAccountMetricsParamsMetricMethodCallsOverTime        FetchAccountMetricsParamsMetric = "method_calls_over_time"
	FetchAccountMetricsParamsMetricMethodResponseTimeMax      FetchAccountMetricsParamsMetric = "method_response_time_max"
	FetchAccountMetricsParamsMetricRequestErrorsOverTime      FetchAccountMetricsParamsMetric = "request_errors_over_time"
	FetchAccountMetricsParamsMetricResponseStatusBreakdown    FetchAccountMetricsParamsMetric = "response_status_breakdown"
	FetchAccountMetricsParamsMetricResponseStatusOverTime     FetchAccountMetricsParamsMetric = "response_status_over_time"
	FetchAccountMetricsParamsMetricTotalRequestErrorsOverTime FetchAccountMetricsParamsMetric = "total_request_errors_over_time"
)

// Chain defines model for chain.
type Chain struct {
	IsSelectChain *bool      `json:"is_select_chain,omitempty"`
	Networks      *[]Network `json:"networks,omitempty"`
	Slug          *string    `json:"slug,omitempty"`
}

// ChainUsage defines model for chain_usage.
type ChainUsage struct {
	CreditsUsed *int    `json:"credits_used,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// Endpoint defines model for endpoint.
type Endpoint struct {
	// Chain chain slug
	Chain   string  `json:"chain"`
	HttpUrl string  `json:"http_url"`
	Id      string  `json:"id"`
	Label   *string `json:"label"`

	// Network network slug
	Network string `json:"network"`
	Tags    *[]struct {
		Label *string `json:"label,omitempty"`
		TagId *int    `json:"tag_id,omitempty"`
	} `json:"tags,omitempty"`
	WssUrl *string `json:"wss_url"`
}

// EndpointDomainMask defines model for endpoint_domain_mask.
type EndpointDomainMask struct {
	Domain *string `json:"domain,omitempty"`
	Id     *string `json:"id,omitempty"`
}

// EndpointIp defines model for endpoint_ip.
type EndpointIp struct {
	Id *string `json:"id,omitempty"`
	Ip *string `json:"ip,omitempty"`
}

// EndpointJwt defines model for endpoint_jwt.
type EndpointJwt struct {
	Id        *string `json:"id,omitempty"`
	Kid       *string `json:"kid,omitempty"`
	Name      *string `json:"name,omitempty"`
	PublicKey *string `json:"public_key,omitempty"`
}

// EndpointMetric defines model for endpoint_metric.
type EndpointMetric struct {
	Data *[][]int `json:"data,omitempty"`
	Tag  *string  `json:"tag,omitempty"`
}

// EndpointRateLimits defines model for endpoint_rate_limits.
type EndpointRateLimits struct {
	Account       *int  `json:"account"`
	RateLimitByIp *bool `json:"rate_limit_by_ip"`
	Rpd           *int  `json:"rpd"`
	Rpm           *int  `json:"rpm"`
	Rps           *int  `json:"rps"`
}

// EndpointReferrer defines model for endpoint_referrer.
type EndpointReferrer struct {
	Id       *string `json:"id,omitempty"`
	Referrer *string `json:"referrer,omitempty"`
}

// EndpointRequestFilter defines model for endpoint_request_filter.
type EndpointRequestFilter struct {
	Id     *string                 `json:"id,omitempty"`
	Method *[]string               `json:"method,omitempty"`
	Params *map[string]interface{} `json:"params,omitempty"`
}

// EndpointSecurity defines model for endpoint_security.
type EndpointSecurity struct {
	DomainMasks *[]EndpointDomainMask `json:"domain_masks,omitempty"`
	Ips         *[]EndpointIp         `json:"ips,omitempty"`
	Jwts        *[]EndpointJwt        `json:"jwts,omitempty"`
	Options     *struct {
		DomainMasks    *bool `json:"domainMasks"`
		IpCustomHeader *struct {
			Value *string `json:"value"`
		} `json:"ipCustomHeader,omitempty"`
		Ips            *bool `json:"ips"`
		Jwts           *bool `json:"jwts"`
		Referrers      *bool `json:"referrers"`
		RequestFilters *bool `json:"requestFilters"`
		Tokens         *bool `json:"tokens"`
	} `json:"options,omitempty"`
	Referrers      *[]EndpointReferrer      `json:"referrers,omitempty"`
	RequestFilters *[]EndpointRequestFilter `json:"request_filters,omitempty"`
	Tokens         *[]EndpointToken         `json:"tokens,omitempty"`
}

// EndpointToken defines model for endpoint_token.
type EndpointToken struct {
	Id    *string `json:"id,omitempty"`
	Token *string `json:"token,omitempty"`
}

// EndpointUsage defines model for endpoint_usage.
type EndpointUsage struct {
	Chain            *string        `json:"chain,omitempty"`
	CreditsUsed      *int           `json:"credits_used,omitempty"`
	Label            *string        `json:"label"`
	MethodsBreakdown *[]MethodUsage `json:"methods_breakdown,omitempty"`
	Name             *string        `json:"name,omitempty"`
	Network          *string        `json:"network,omitempty"`
	Requests         *int           `json:"requests,omitempty"`
	Status           *string        `json:"status,omitempty"`
}

// Invoice defines model for invoice.
type Invoice struct {
	AmountDue     *int    `json:"amount_due,omitempty"`
	AmountPaid    *int    `json:"amount_paid,omitempty"`
	BillingReason *string `json:"billing_reason,omitempty"`
	Created       *int    `json:"created,omitempty"`
	Id            *string `json:"id,omitempty"`
	Lines         *[]struct {
		Amount      *int    `json:"amount,omitempty"`
		Description *string `json:"description,omitempty"`
	} `json:"lines,omitempty"`
	PeriodEnd   *int    `json:"period_end,omitempty"`
	PeriodStart *int    `json:"period_start,omitempty"`
	Status      *string `json:"status,omitempty"`
	Subtotal    *int    `json:"subtotal,omitempty"`
}

// MethodUsage defines model for method_usage.
type MethodUsage struct {
	Archive     *bool   `json:"archive"`
	Chain       *string `json:"chain,omitempty"`
	CreditsUsed *int    `json:"credits_used,omitempty"`
	MethodName  *string `json:"method_name,omitempty"`
	Network     *string `json:"network,omitempty"`
}

// Network defines model for network.
type Network struct {
	ChainId *int    `json:"chain_id"`
	Name    *string `json:"name,omitempty"`
	Slug    *string `json:"slug,omitempty"`
}

// Payment defines model for payment.
type Payment struct {
	Amount            *string `json:"amount,omitempty"`
	CardLast4         *string `json:"card_last_4"`
	CreatedAt         *string `json:"created_at,omitempty"`
	Currency          *string `json:"currency,omitempty"`
	MarketplaceAmount *int    `json:"marketplace_amount"`
	Status            *string `json:"status,omitempty"`
}

// SingleEndpoint defines model for single_endpoint.
type SingleEndpoint struct {
	// Chain chain slug
	Chain   string  `json:"chain"`
	HttpUrl string  `json:"http_url"`
	Id      string  `json:"id"`
	Label   *string `json:"label"`

	// Network network slug
	Network    string              `json:"network"`
	RateLimits *EndpointRateLimits `json:"rate_limits,omitempty"`
	Security   EndpointSecurity    `json:"security"`
	Status     *string             `json:"status,omitempty"`
	Tags       *[]struct {
		Label *string `json:"label,omitempty"`
		TagId *int    `json:"tag_id,omitempty"`
	} `json:"tags,omitempty"`
	WssUrl *string `json:"wss_url"`
}

// ListEndpointsParams defines parameters for ListEndpoints.
type ListEndpointsParams struct {
	Limit     *int      `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *int      `form:"offset,omitempty" json:"offset,omitempty"`
	TagIds    *[]int    `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`
	TagLabels *[]string `form:"tag_labels,omitempty" json:"tag_labels,omitempty"`
}

// CreateEndpointJSONBody defines parameters for CreateEndpoint.
type CreateEndpointJSONBody struct {
	Chain   *string `json:"chain,omitempty"`
	Network *string `json:"network,omitempty"`
}

// UpdateEndpointJSONBody defines parameters for UpdateEndpoint.
type UpdateEndpointJSONBody struct {
	Label *string `json:"label,omitempty"`
}

// CreateOrUpdateIpCustomHeaderJSONBody defines parameters for CreateOrUpdateIpCustomHeader.
type CreateOrUpdateIpCustomHeaderJSONBody struct {
	// HeaderName IP custom header name
	HeaderName string `json:"header_name"`
}

// GetLogDetailsParams defines parameters for GetLogDetails.
type GetLogDetailsParams struct {
	RequestId string `form:"request_id" json:"request_id"`
}

// GetEndpointLogsParams defines parameters for GetEndpointLogs.
type GetEndpointLogsParams struct {
	IncludeDetails *bool   `form:"include_details,omitempty" json:"include_details,omitempty"`
	Limit          *int    `form:"limit,omitempty" json:"limit,omitempty"`
	NextAt         *string `form:"next_at,omitempty" json:"next_at,omitempty"`
	From           string  `form:"from" json:"from"`
	To             string  `form:"to" json:"to"`
}

// CreateMethodRateLimitJSONBody defines parameters for CreateMethodRateLimit.
type CreateMethodRateLimitJSONBody struct {
	Interval CreateMethodRateLimitJSONBodyInterval `json:"interval"`
	Methods  []string                              `json:"methods"`
	Rate     int                                   `json:"rate"`
}

// CreateMethodRateLimitJSONBodyInterval defines parameters for CreateMethodRateLimit.
type CreateMethodRateLimitJSONBodyInterval string

// UpdateMethodRateLimitJSONBody defines parameters for UpdateMethodRateLimit.
type UpdateMethodRateLimitJSONBody struct {
	Methods *[]string                            `json:"methods,omitempty"`
	Rate    *int                                 `json:"rate,omitempty"`
	Status  *UpdateMethodRateLimitJSONBodyStatus `json:"status,omitempty"`
}

// UpdateMethodRateLimitJSONBodyStatus defines parameters for UpdateMethodRateLimit.
type UpdateMethodRateLimitJSONBodyStatus string

// FetchEndpointMetricParams defines parameters for FetchEndpointMetric.
type FetchEndpointMetricParams struct {
	// Period hour, day, week, month
	Period FetchEndpointMetricParamsPeriod `form:"period" json:"period"`

	// Metric method_calls_over_time, response_status_over_time, method_call_breakdown, response_status_breakdown, method_response_time_max, request_errors_over_time, total_request_errors_over_time
	Metric FetchEndpointMetricParamsMetric `form:"metric" json:"metric"`
}

// FetchEndpointMetricParamsPeriod defines parameters for FetchEndpointMetric.
type FetchEndpointMetricParamsPeriod string

// FetchEndpointMetricParamsMetric defines parameters for FetchEndpointMetric.
type FetchEndpointMetricParamsMetric string

// UpdateRateLimitsJSONBody defines parameters for UpdateRateLimits.
type UpdateRateLimitsJSONBody struct {
	RateLimits struct {
		Rpd *int `json:"rpd,omitempty"`
		Rpm *int `json:"rpm,omitempty"`
		Rps *int `json:"rps,omitempty"`
	} `json:"rate_limits"`
}

// CreateDomainMaskJSONBody defines parameters for CreateDomainMask.
type CreateDomainMaskJSONBody struct {
	DomainMask *string `json:"domain_mask,omitempty"`
}

// CreateIpJSONBody defines parameters for CreateIp.
type CreateIpJSONBody struct {
	Ip *string `json:"ip,omitempty"`
}

// CreateJwtJSONBody defines parameters for CreateJwt.
type CreateJwtJSONBody struct {
	Kid       *string `json:"kid,omitempty"`
	Name      *string `json:"name,omitempty"`
	PublicKey *string `json:"public_key,omitempty"`
}

// CreateReferrerJSONBody defines parameters for CreateReferrer.
type CreateReferrerJSONBody struct {
	Referrer *string `json:"referrer,omitempty"`
}

// CreateRequestFilterJSONBody defines parameters for CreateRequestFilter.
type CreateRequestFilterJSONBody struct {
	// Method Array of method names for whitelisting
	Method *[]string `json:"method,omitempty"`
}

// UpdateRequestFilterJSONBody defines parameters for UpdateRequestFilter.
type UpdateRequestFilterJSONBody struct {
	// Method Array of method names for whitelisting
	Method *[]string `json:"method,omitempty"`
}

// UpdateSecurityOptionsJSONBody defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBody struct {
	Options struct {
		Cors           *UpdateSecurityOptionsJSONBodyOptionsCors           `json:"cors,omitempty"`
		DomainMasks    *UpdateSecurityOptionsJSONBodyOptionsDomainMasks    `json:"domainMasks,omitempty"`
		Hsts           *UpdateSecurityOptionsJSONBodyOptionsHsts           `json:"hsts,omitempty"`
		IpCustomHeader *UpdateSecurityOptionsJSONBodyOptionsIpCustomHeader `json:"ipCustomHeader,omitempty"`
		Ips            *UpdateSecurityOptionsJSONBodyOptionsIps            `json:"ips,omitempty"`
		Jwts           *UpdateSecurityOptionsJSONBodyOptionsJwts           `json:"jwts,omitempty"`
		Referrers      *UpdateSecurityOptionsJSONBodyOptionsReferrers      `json:"referrers,omitempty"`
		RequestFilters *UpdateSecurityOptionsJSONBodyOptionsRequestFilters `json:"requestFilters,omitempty"`
		Tokens         *UpdateSecurityOptionsJSONBodyOptionsTokens         `json:"tokens,omitempty"`
	} `json:"options"`
}

// UpdateSecurityOptionsJSONBodyOptionsCors defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsCors string

// UpdateSecurityOptionsJSONBodyOptionsDomainMasks defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsDomainMasks string

// UpdateSecurityOptionsJSONBodyOptionsHsts defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsHsts string

// UpdateSecurityOptionsJSONBodyOptionsIpCustomHeader defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsIpCustomHeader string

// UpdateSecurityOptionsJSONBodyOptionsIps defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsIps string

// UpdateSecurityOptionsJSONBodyOptionsJwts defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsJwts string

// UpdateSecurityOptionsJSONBodyOptionsReferrers defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsReferrers string

// UpdateSecurityOptionsJSONBodyOptionsRequestFilters defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsRequestFilters string

// UpdateSecurityOptionsJSONBodyOptionsTokens defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsTokens string

// UpdateEndpointStatusJSONBody defines parameters for UpdateEndpointStatus.
type UpdateEndpointStatusJSONBody struct {
	Status UpdateEndpointStatusJSONBodyStatus `json:"status"`
}

// UpdateEndpointStatusJSONBodyStatus defines parameters for UpdateEndpointStatus.
type UpdateEndpointStatusJSONBodyStatus string

// CreateTagJSONBody defines parameters for CreateTag.
type CreateTagJSONBody struct {
	Label *string `json:"label,omitempty"`
}

// FetchAccountMetricsParams defines parameters for FetchAccountMetrics.
type FetchAccountMetricsParams struct {
	// Period hour, day, week, month
	Period FetchAccountMetricsParamsPeriod `form:"period" json:"period"`

	// Metric method_calls_over_time, response_status_over_time, method_call_breakdown, response_status_breakdown, method_response_time_max, request_errors_over_time, total_request_errors_over_time
	Metric FetchAccountMetricsParamsMetric `form:"metric" json:"metric"`

	// Percentile Percentile for response time metrics
	Percentile *string `form:"percentile,omitempty" json:"percentile,omitempty"`
}

// FetchAccountMetricsParamsPeriod defines parameters for FetchAccountMetrics.
type FetchAccountMetricsParamsPeriod string

// FetchAccountMetricsParamsMetric defines parameters for FetchAccountMetrics.
type FetchAccountMetricsParamsMetric string

// UsageParams defines parameters for Usage.
type UsageParams struct {
	// StartTime Start time
	StartTime *int `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End time
	EndTime *int `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// UsageByChainParams defines parameters for UsageByChain.
type UsageByChainParams struct {
	// StartTime Start time
	StartTime *int `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End time
	EndTime *int `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// UsageByEndpointParams defines parameters for UsageByEndpoint.
type UsageByEndpointParams struct {
	// StartTime Start time
	StartTime *int `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End time
	EndTime *int `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// UsageByMethodParams defines parameters for UsageByMethod.
type UsageByMethodParams struct {
	// StartTime Start time
	StartTime *int `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End time
	EndTime *int `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// CreateEndpointJSONRequestBody defines body for CreateEndpoint for application/json ContentType.
type CreateEndpointJSONRequestBody CreateEndpointJSONBody

// UpdateEndpointJSONRequestBody defines body for UpdateEndpoint for application/json ContentType.
type UpdateEndpointJSONRequestBody UpdateEndpointJSONBody

// CreateOrUpdateIpCustomHeaderJSONRequestBody defines body for CreateOrUpdateIpCustomHeader for application/json ContentType.
type CreateOrUpdateIpCustomHeaderJSONRequestBody CreateOrUpdateIpCustomHeaderJSONBody

// CreateMethodRateLimitJSONRequestBody defines body for CreateMethodRateLimit for application/json ContentType.
type CreateMethodRateLimitJSONRequestBody CreateMethodRateLimitJSONBody

// UpdateMethodRateLimitJSONRequestBody defines body for UpdateMethodRateLimit for application/json ContentType.
type UpdateMethodRateLimitJSONRequestBody UpdateMethodRateLimitJSONBody

// UpdateRateLimitsJSONRequestBody defines body for UpdateRateLimits for application/json ContentType.
type UpdateRateLimitsJSONRequestBody UpdateRateLimitsJSONBody

// CreateDomainMaskJSONRequestBody defines body for CreateDomainMask for application/json ContentType.
type CreateDomainMaskJSONRequestBody CreateDomainMaskJSONBody

// CreateIpJSONRequestBody defines body for CreateIp for application/json ContentType.
type CreateIpJSONRequestBody CreateIpJSONBody

// CreateJwtJSONRequestBody defines body for CreateJwt for application/json ContentType.
type CreateJwtJSONRequestBody CreateJwtJSONBody

// CreateReferrerJSONRequestBody defines body for CreateReferrer for application/json ContentType.
type CreateReferrerJSONRequestBody CreateReferrerJSONBody

// CreateRequestFilterJSONRequestBody defines body for CreateRequestFilter for application/json ContentType.
type CreateRequestFilterJSONRequestBody CreateRequestFilterJSONBody

// UpdateRequestFilterJSONRequestBody defines body for UpdateRequestFilter for application/json ContentType.
type UpdateRequestFilterJSONRequestBody UpdateRequestFilterJSONBody

// UpdateSecurityOptionsJSONRequestBody defines body for UpdateSecurityOptions for application/json ContentType.
type UpdateSecurityOptionsJSONRequestBody UpdateSecurityOptionsJSONBody

// UpdateEndpointStatusJSONRequestBody defines body for UpdateEndpointStatus for application/json ContentType.
type UpdateEndpointStatusJSONRequestBody UpdateEndpointStatusJSONBody

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody CreateTagJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Invoices request
	Invoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Payments request
	Payments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Chains request
	Chains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEndpoints request
	ListEndpoints(ctx context.Context, params *ListEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEndpointWithBody request with any body
	CreateEndpointWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEndpoint(ctx context.Context, body CreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveEndpoint request
	ArchiveEndpoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowEndpoint request
	ShowEndpoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEndpointWithBody request with any body
	UpdateEndpointWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEndpoint(ctx context.Context, id string, body UpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableMultichain request
	DisableMultichain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableMultichain request
	EnableMultichain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIpCustomHeader request
	DeleteIpCustomHeader(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateIpCustomHeaderWithBody request with any body
	CreateOrUpdateIpCustomHeaderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateIpCustomHeader(ctx context.Context, id string, body CreateOrUpdateIpCustomHeaderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogDetails request
	GetLogDetails(ctx context.Context, id string, params *GetLogDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEndpointLogs request
	GetEndpointLogs(ctx context.Context, id string, params *GetEndpointLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMethodRateLimits request
	GetMethodRateLimits(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMethodRateLimitWithBody request with any body
	CreateMethodRateLimitWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMethodRateLimit(ctx context.Context, id string, body CreateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMethodRateLimit request
	DeleteMethodRateLimit(ctx context.Context, id string, methodRateLimitId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMethodRateLimitWithBody request with any body
	UpdateMethodRateLimitWithBody(ctx context.Context, id string, methodRateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMethodRateLimit(ctx context.Context, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchEndpointMetric request
	FetchEndpointMetric(ctx context.Context, id string, params *FetchEndpointMetricParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRateLimitsWithBody request with any body
	UpdateRateLimitsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRateLimits(ctx context.Context, id string, body UpdateRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDomainMaskWithBody request with any body
	CreateDomainMaskWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDomainMask(ctx context.Context, id string, body CreateDomainMaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDomainMask request
	DeleteDomainMask(ctx context.Context, id string, domainMaskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIpWithBody request with any body
	CreateIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIp(ctx context.Context, id string, body CreateIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIp request
	DeleteIp(ctx context.Context, id string, ipId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJwtWithBody request with any body
	CreateJwtWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJwt(ctx context.Context, id string, body CreateJwtJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJwt request
	DeleteJwt(ctx context.Context, id string, jwtId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReferrerWithBody request with any body
	CreateReferrerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReferrer(ctx context.Context, id string, body CreateReferrerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReferrer request
	DeleteReferrer(ctx context.Context, id string, referrerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRequestFilterWithBody request with any body
	CreateRequestFilterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRequestFilter(ctx context.Context, id string, body CreateRequestFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRequestFilter request
	DeleteRequestFilter(ctx context.Context, id string, requestFilterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRequestFilterWithBody request with any body
	UpdateRequestFilterWithBody(ctx context.Context, id string, requestFilterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRequestFilter(ctx context.Context, id string, requestFilterId string, body UpdateRequestFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthenticationToken request
	CreateAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, id string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurityOptions request
	GetSecurityOptions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSecurityOptionsWithBody request with any body
	UpdateSecurityOptionsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSecurityOptions(ctx context.Context, id string, body UpdateSecurityOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEndpointStatusWithBody request with any body
	UpdateEndpointStatusWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEndpointStatus(ctx context.Context, id string, body UpdateEndpointStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTagWithBody request with any body
	CreateTagWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTag(ctx context.Context, id string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchAccountMetrics request
	FetchAccountMetrics(ctx context.Context, params *FetchAccountMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Usage request
	Usage(ctx context.Context, params *UsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsageByChain request
	UsageByChain(ctx context.Context, params *UsageByChainParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsageByEndpoint request
	UsageByEndpoint(ctx context.Context, params *UsageByEndpointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsageByMethod request
	UsageByMethod(ctx context.Context, params *UsageByMethodParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Invoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvoicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Payments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPaymentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Chains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEndpoints(ctx context.Context, params *ListEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEndpointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEndpointWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEndpointRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEndpoint(ctx context.Context, body CreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEndpointRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveEndpoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveEndpointRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowEndpoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowEndpointRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEndpointWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEndpointRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEndpoint(ctx context.Context, id string, body UpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEndpointRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableMultichain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableMultichainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableMultichain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableMultichainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIpCustomHeader(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIpCustomHeaderRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateIpCustomHeaderWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateIpCustomHeaderRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateIpCustomHeader(ctx context.Context, id string, body CreateOrUpdateIpCustomHeaderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateIpCustomHeaderRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogDetails(ctx context.Context, id string, params *GetLogDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogDetailsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEndpointLogs(ctx context.Context, id string, params *GetEndpointLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEndpointLogsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMethodRateLimits(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMethodRateLimitsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMethodRateLimitWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMethodRateLimitRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMethodRateLimit(ctx context.Context, id string, body CreateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMethodRateLimitRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMethodRateLimit(ctx context.Context, id string, methodRateLimitId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMethodRateLimitRequest(c.Server, id, methodRateLimitId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMethodRateLimitWithBody(ctx context.Context, id string, methodRateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMethodRateLimitRequestWithBody(c.Server, id, methodRateLimitId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMethodRateLimit(ctx context.Context, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMethodRateLimitRequest(c.Server, id, methodRateLimitId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchEndpointMetric(ctx context.Context, id string, params *FetchEndpointMetricParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchEndpointMetricRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRateLimitsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRateLimitsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRateLimits(ctx context.Context, id string, body UpdateRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRateLimitsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomainMaskWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainMaskRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomainMask(ctx context.Context, id string, body CreateDomainMaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainMaskRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDomainMask(ctx context.Context, id string, domainMaskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDomainMaskRequest(c.Server, id, domainMaskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIp(ctx context.Context, id string, body CreateIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIp(ctx context.Context, id string, ipId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIpRequest(c.Server, id, ipId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJwtWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJwtRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJwt(ctx context.Context, id string, body CreateJwtJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJwtRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJwt(ctx context.Context, id string, jwtId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJwtRequest(c.Server, id, jwtId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReferrerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReferrerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReferrer(ctx context.Context, id string, body CreateReferrerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReferrerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReferrer(ctx context.Context, id string, referrerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReferrerRequest(c.Server, id, referrerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequestFilterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestFilterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequestFilter(ctx context.Context, id string, body CreateRequestFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestFilterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRequestFilter(ctx context.Context, id string, requestFilterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequestFilterRequest(c.Server, id, requestFilterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRequestFilterWithBody(ctx context.Context, id string, requestFilterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestFilterRequestWithBody(c.Server, id, requestFilterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRequestFilter(ctx context.Context, id string, requestFilterId string, body UpdateRequestFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestFilterRequest(c.Server, id, requestFilterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthenticationTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, id string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, id, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurityOptions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityOptionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSecurityOptionsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSecurityOptionsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSecurityOptions(ctx context.Context, id string, body UpdateSecurityOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSecurityOptionsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEndpointStatusWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEndpointStatusRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEndpointStatus(ctx context.Context, id string, body UpdateEndpointStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEndpointStatusRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTag(ctx context.Context, id string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchAccountMetrics(ctx context.Context, params *FetchAccountMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchAccountMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Usage(ctx context.Context, params *UsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsageByChain(ctx context.Context, params *UsageByChainParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageByChainRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsageByEndpoint(ctx context.Context, params *UsageByEndpointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageByEndpointRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsageByMethod(ctx context.Context, params *UsageByMethodParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageByMethodRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewInvoicesRequest generates requests for Invoices
func NewInvoicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/billing/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPaymentsRequest generates requests for Payments
func NewPaymentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/billing/payments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChainsRequest generates requests for Chains
func NewChainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/chains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEndpointsRequest generates requests for ListEndpoints
func NewListEndpointsRequest(server string, params *ListEndpointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag_ids", runtime.ParamLocationQuery, *params.TagIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TagLabels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag_labels", runtime.ParamLocationQuery, *params.TagLabels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEndpointRequest calls the generic CreateEndpoint builder with application/json body
func NewCreateEndpointRequest(server string, body CreateEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEndpointRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEndpointRequestWithBody generates requests for CreateEndpoint with any type of body
func NewCreateEndpointRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveEndpointRequest generates requests for ArchiveEndpoint
func NewArchiveEndpointRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowEndpointRequest generates requests for ShowEndpoint
func NewShowEndpointRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEndpointRequest calls the generic UpdateEndpoint builder with application/json body
func NewUpdateEndpointRequest(server string, id string, body UpdateEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEndpointRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateEndpointRequestWithBody generates requests for UpdateEndpoint with any type of body
func NewUpdateEndpointRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableMultichainRequest generates requests for DisableMultichain
func NewDisableMultichainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/disable_multichain", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableMultichainRequest generates requests for EnableMultichain
func NewEnableMultichainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/enable_multichain", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteIpCustomHeaderRequest generates requests for DeleteIpCustomHeader
func NewDeleteIpCustomHeaderRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/ip_custom_header", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateIpCustomHeaderRequest calls the generic CreateOrUpdateIpCustomHeader builder with application/json body
func NewCreateOrUpdateIpCustomHeaderRequest(server string, id string, body CreateOrUpdateIpCustomHeaderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateIpCustomHeaderRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateOrUpdateIpCustomHeaderRequestWithBody generates requests for CreateOrUpdateIpCustomHeader with any type of body
func NewCreateOrUpdateIpCustomHeaderRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/ip_custom_header", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogDetailsRequest generates requests for GetLogDetails
func NewGetLogDetailsRequest(server string, id string, params *GetLogDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/log_details", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "request_id", runtime.ParamLocationQuery, params.RequestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEndpointLogsRequest generates requests for GetEndpointLogs
func NewGetEndpointLogsRequest(server string, id string, params *GetEndpointLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeDetails != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_details", runtime.ParamLocationQuery, *params.IncludeDetails); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_at", runtime.ParamLocationQuery, *params.NextAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMethodRateLimitsRequest generates requests for GetMethodRateLimits
func NewGetMethodRateLimitsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/method-rate-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMethodRateLimitRequest calls the generic CreateMethodRateLimit builder with application/json body
func NewCreateMethodRateLimitRequest(server string, id string, body CreateMethodRateLimitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMethodRateLimitRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateMethodRateLimitRequestWithBody generates requests for CreateMethodRateLimit with any type of body
func NewCreateMethodRateLimitRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/method-rate-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMethodRateLimitRequest generates requests for DeleteMethodRateLimit
func NewDeleteMethodRateLimitRequest(server string, id string, methodRateLimitId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "method_rate_limit_id", runtime.ParamLocationPath, methodRateLimitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/method-rate-limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMethodRateLimitRequest calls the generic UpdateMethodRateLimit builder with application/json body
func NewUpdateMethodRateLimitRequest(server string, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMethodRateLimitRequestWithBody(server, id, methodRateLimitId, "application/json", bodyReader)
}

// NewUpdateMethodRateLimitRequestWithBody generates requests for UpdateMethodRateLimit with any type of body
func NewUpdateMethodRateLimitRequestWithBody(server string, id string, methodRateLimitId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "method_rate_limit_id", runtime.ParamLocationPath, methodRateLimitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/method-rate-limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFetchEndpointMetricRequest generates requests for FetchEndpointMetric
func NewFetchEndpointMetricRequest(server string, id string, params *FetchEndpointMetricParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period", runtime.ParamLocationQuery, params.Period); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metric", runtime.ParamLocationQuery, params.Metric); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRateLimitsRequest calls the generic UpdateRateLimits builder with application/json body
func NewUpdateRateLimitsRequest(server string, id string, body UpdateRateLimitsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRateLimitsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateRateLimitsRequestWithBody generates requests for UpdateRateLimits with any type of body
func NewUpdateRateLimitsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/rate-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDomainMaskRequest calls the generic CreateDomainMask builder with application/json body
func NewCreateDomainMaskRequest(server string, id string, body CreateDomainMaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDomainMaskRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateDomainMaskRequestWithBody generates requests for CreateDomainMask with any type of body
func NewCreateDomainMaskRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/domain_masks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDomainMaskRequest generates requests for DeleteDomainMask
func NewDeleteDomainMaskRequest(server string, id string, domainMaskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domain_mask_id", runtime.ParamLocationPath, domainMaskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/domain_masks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIpRequest calls the generic CreateIp builder with application/json body
func NewCreateIpRequest(server string, id string, body CreateIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIpRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateIpRequestWithBody generates requests for CreateIp with any type of body
func NewCreateIpRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/ips", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIpRequest generates requests for DeleteIp
func NewDeleteIpRequest(server string, id string, ipId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ip_id", runtime.ParamLocationPath, ipId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/ips/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJwtRequest calls the generic CreateJwt builder with application/json body
func NewCreateJwtRequest(server string, id string, body CreateJwtJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJwtRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateJwtRequestWithBody generates requests for CreateJwt with any type of body
func NewCreateJwtRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/jwts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJwtRequest generates requests for DeleteJwt
func NewDeleteJwtRequest(server string, id string, jwtId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "jwt_id", runtime.ParamLocationPath, jwtId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/jwts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateReferrerRequest calls the generic CreateReferrer builder with application/json body
func NewCreateReferrerRequest(server string, id string, body CreateReferrerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReferrerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateReferrerRequestWithBody generates requests for CreateReferrer with any type of body
func NewCreateReferrerRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/referrers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReferrerRequest generates requests for DeleteReferrer
func NewDeleteReferrerRequest(server string, id string, referrerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "referrer_id", runtime.ParamLocationPath, referrerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/referrers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequestFilterRequest calls the generic CreateRequestFilter builder with application/json body
func NewCreateRequestFilterRequest(server string, id string, body CreateRequestFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestFilterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateRequestFilterRequestWithBody generates requests for CreateRequestFilter with any type of body
func NewCreateRequestFilterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/request_filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRequestFilterRequest generates requests for DeleteRequestFilter
func NewDeleteRequestFilterRequest(server string, id string, requestFilterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "request_filter_id", runtime.ParamLocationPath, requestFilterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/request_filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequestFilterRequest calls the generic UpdateRequestFilter builder with application/json body
func NewUpdateRequestFilterRequest(server string, id string, requestFilterId string, body UpdateRequestFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestFilterRequestWithBody(server, id, requestFilterId, "application/json", bodyReader)
}

// NewUpdateRequestFilterRequestWithBody generates requests for UpdateRequestFilter with any type of body
func NewUpdateRequestFilterRequestWithBody(server string, id string, requestFilterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "request_filter_id", runtime.ParamLocationPath, requestFilterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/request_filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAuthenticationTokenRequest generates requests for CreateAuthenticationToken
func NewCreateAuthenticationTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, id string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecurityOptionsRequest generates requests for GetSecurityOptions
func NewGetSecurityOptionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security_options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSecurityOptionsRequest calls the generic UpdateSecurityOptions builder with application/json body
func NewUpdateSecurityOptionsRequest(server string, id string, body UpdateSecurityOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSecurityOptionsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateSecurityOptionsRequestWithBody generates requests for UpdateSecurityOptions with any type of body
func NewUpdateSecurityOptionsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security_options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateEndpointStatusRequest calls the generic UpdateEndpointStatus builder with application/json body
func NewUpdateEndpointStatusRequest(server string, id string, body UpdateEndpointStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEndpointStatusRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateEndpointStatusRequestWithBody generates requests for UpdateEndpointStatus with any type of body
func NewUpdateEndpointStatusRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTagRequest calls the generic CreateTag builder with application/json body
func NewCreateTagRequest(server string, id string, body CreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateTagRequestWithBody generates requests for CreateTag with any type of body
func NewCreateTagRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFetchAccountMetricsRequest generates requests for FetchAccountMetrics
func NewFetchAccountMetricsRequest(server string, params *FetchAccountMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period", runtime.ParamLocationQuery, params.Period); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metric", runtime.ParamLocationQuery, params.Metric); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Percentile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "percentile", runtime.ParamLocationQuery, *params.Percentile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageRequest generates requests for Usage
func NewUsageRequest(server string, params *UsageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/usage/rpc")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageByChainRequest generates requests for UsageByChain
func NewUsageByChainRequest(server string, params *UsageByChainParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/usage/rpc/by-chain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageByEndpointRequest generates requests for UsageByEndpoint
func NewUsageByEndpointRequest(server string, params *UsageByEndpointParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/usage/rpc/by-endpoint")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageByMethodRequest generates requests for UsageByMethod
func NewUsageByMethodRequest(server string, params *UsageByMethodParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/usage/rpc/by-method")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// InvoicesWithResponse request
	InvoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InvoicesResponse, error)

	// PaymentsWithResponse request
	PaymentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PaymentsResponse, error)

	// ChainsWithResponse request
	ChainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ChainsResponse, error)

	// ListEndpointsWithResponse request
	ListEndpointsWithResponse(ctx context.Context, params *ListEndpointsParams, reqEditors ...RequestEditorFn) (*ListEndpointsResponse, error)

	// CreateEndpointWithBodyWithResponse request with any body
	CreateEndpointWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEndpointResponse, error)

	CreateEndpointWithResponse(ctx context.Context, body CreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEndpointResponse, error)

	// ArchiveEndpointWithResponse request
	ArchiveEndpointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ArchiveEndpointResponse, error)

	// ShowEndpointWithResponse request
	ShowEndpointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ShowEndpointResponse, error)

	// UpdateEndpointWithBodyWithResponse request with any body
	UpdateEndpointWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEndpointResponse, error)

	UpdateEndpointWithResponse(ctx context.Context, id string, body UpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEndpointResponse, error)

	// DisableMultichainWithResponse request
	DisableMultichainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DisableMultichainResponse, error)

	// EnableMultichainWithResponse request
	EnableMultichainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EnableMultichainResponse, error)

	// DeleteIpCustomHeaderWithResponse request
	DeleteIpCustomHeaderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteIpCustomHeaderResponse, error)

	// CreateOrUpdateIpCustomHeaderWithBodyWithResponse request with any body
	CreateOrUpdateIpCustomHeaderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateIpCustomHeaderResponse, error)

	CreateOrUpdateIpCustomHeaderWithResponse(ctx context.Context, id string, body CreateOrUpdateIpCustomHeaderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateIpCustomHeaderResponse, error)

	// GetLogDetailsWithResponse request
	GetLogDetailsWithResponse(ctx context.Context, id string, params *GetLogDetailsParams, reqEditors ...RequestEditorFn) (*GetLogDetailsResponse, error)

	// GetEndpointLogsWithResponse request
	GetEndpointLogsWithResponse(ctx context.Context, id string, params *GetEndpointLogsParams, reqEditors ...RequestEditorFn) (*GetEndpointLogsResponse, error)

	// GetMethodRateLimitsWithResponse request
	GetMethodRateLimitsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMethodRateLimitsResponse, error)

	// CreateMethodRateLimitWithBodyWithResponse request with any body
	CreateMethodRateLimitWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMethodRateLimitResponse, error)

	CreateMethodRateLimitWithResponse(ctx context.Context, id string, body CreateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMethodRateLimitResponse, error)

	// DeleteMethodRateLimitWithResponse request
	DeleteMethodRateLimitWithResponse(ctx context.Context, id string, methodRateLimitId string, reqEditors ...RequestEditorFn) (*DeleteMethodRateLimitResponse, error)

	// UpdateMethodRateLimitWithBodyWithResponse request with any body
	UpdateMethodRateLimitWithBodyWithResponse(ctx context.Context, id string, methodRateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMethodRateLimitResponse, error)

	UpdateMethodRateLimitWithResponse(ctx context.Context, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMethodRateLimitResponse, error)

	// FetchEndpointMetricWithResponse request
	FetchEndpointMetricWithResponse(ctx context.Context, id string, params *FetchEndpointMetricParams, reqEditors ...RequestEditorFn) (*FetchEndpointMetricResponse, error)

	// UpdateRateLimitsWithBodyWithResponse request with any body
	UpdateRateLimitsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRateLimitsResponse, error)

	UpdateRateLimitsWithResponse(ctx context.Context, id string, body UpdateRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRateLimitsResponse, error)

	// CreateDomainMaskWithBodyWithResponse request with any body
	CreateDomainMaskWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainMaskResponse, error)

	CreateDomainMaskWithResponse(ctx context.Context, id string, body CreateDomainMaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainMaskResponse, error)

	// DeleteDomainMaskWithResponse request
	DeleteDomainMaskWithResponse(ctx context.Context, id string, domainMaskId string, reqEditors ...RequestEditorFn) (*DeleteDomainMaskResponse, error)

	// CreateIpWithBodyWithResponse request with any body
	CreateIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpResponse, error)

	CreateIpWithResponse(ctx context.Context, id string, body CreateIpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpResponse, error)

	// DeleteIpWithResponse request
	DeleteIpWithResponse(ctx context.Context, id string, ipId string, reqEditors ...RequestEditorFn) (*DeleteIpResponse, error)

	// CreateJwtWithBodyWithResponse request with any body
	CreateJwtWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJwtResponse, error)

	CreateJwtWithResponse(ctx context.Context, id string, body CreateJwtJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJwtResponse, error)

	// DeleteJwtWithResponse request
	DeleteJwtWithResponse(ctx context.Context, id string, jwtId string, reqEditors ...RequestEditorFn) (*DeleteJwtResponse, error)

	// CreateReferrerWithBodyWithResponse request with any body
	CreateReferrerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReferrerResponse, error)

	CreateReferrerWithResponse(ctx context.Context, id string, body CreateReferrerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReferrerResponse, error)

	// DeleteReferrerWithResponse request
	DeleteReferrerWithResponse(ctx context.Context, id string, referrerId string, reqEditors ...RequestEditorFn) (*DeleteReferrerResponse, error)

	// CreateRequestFilterWithBodyWithResponse request with any body
	CreateRequestFilterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequestFilterResponse, error)

	CreateRequestFilterWithResponse(ctx context.Context, id string, body CreateRequestFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequestFilterResponse, error)

	// DeleteRequestFilterWithResponse request
	DeleteRequestFilterWithResponse(ctx context.Context, id string, requestFilterId string, reqEditors ...RequestEditorFn) (*DeleteRequestFilterResponse, error)

	// UpdateRequestFilterWithBodyWithResponse request with any body
	UpdateRequestFilterWithBodyWithResponse(ctx context.Context, id string, requestFilterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequestFilterResponse, error)

	UpdateRequestFilterWithResponse(ctx context.Context, id string, requestFilterId string, body UpdateRequestFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRequestFilterResponse, error)

	// CreateAuthenticationTokenWithResponse request
	CreateAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CreateAuthenticationTokenResponse, error)

	// DeleteTokenWithResponse request
	DeleteTokenWithResponse(ctx context.Context, id string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// GetSecurityOptionsWithResponse request
	GetSecurityOptionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSecurityOptionsResponse, error)

	// UpdateSecurityOptionsWithBodyWithResponse request with any body
	UpdateSecurityOptionsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSecurityOptionsResponse, error)

	UpdateSecurityOptionsWithResponse(ctx context.Context, id string, body UpdateSecurityOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSecurityOptionsResponse, error)

	// UpdateEndpointStatusWithBodyWithResponse request with any body
	UpdateEndpointStatusWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEndpointStatusResponse, error)

	UpdateEndpointStatusWithResponse(ctx context.Context, id string, body UpdateEndpointStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEndpointStatusResponse, error)

	// CreateTagWithBodyWithResponse request with any body
	CreateTagWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	CreateTagWithResponse(ctx context.Context, id string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	// FetchAccountMetricsWithResponse request
	FetchAccountMetricsWithResponse(ctx context.Context, params *FetchAccountMetricsParams, reqEditors ...RequestEditorFn) (*FetchAccountMetricsResponse, error)

	// UsageWithResponse request
	UsageWithResponse(ctx context.Context, params *UsageParams, reqEditors ...RequestEditorFn) (*UsageResponse, error)

	// UsageByChainWithResponse request
	UsageByChainWithResponse(ctx context.Context, params *UsageByChainParams, reqEditors ...RequestEditorFn) (*UsageByChainResponse, error)

	// UsageByEndpointWithResponse request
	UsageByEndpointWithResponse(ctx context.Context, params *UsageByEndpointParams, reqEditors ...RequestEditorFn) (*UsageByEndpointResponse, error)

	// UsageByMethodWithResponse request
	UsageByMethodWithResponse(ctx context.Context, params *UsageByMethodParams, reqEditors ...RequestEditorFn) (*UsageByMethodResponse, error)
}

type InvoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Invoices *[]Invoice `json:"invoices,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r InvoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PaymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Payments *[]Payment `json:"payments,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PaymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PaymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  []Chain `json:"data"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r ChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *[]Endpoint `json:"data"`
		Error *string     `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  SingleEndpoint `json:"data"`
		Error *string        `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *SingleEndpoint `json:"data,omitempty"`
		Error *string         `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r ShowEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableMultichainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisableMultichainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableMultichainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableMultichainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnableMultichainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableMultichainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIpCustomHeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *bool   `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteIpCustomHeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIpCustomHeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateIpCustomHeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			HeaderName *string `json:"header_name,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateIpCustomHeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateIpCustomHeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetLogDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEndpointLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetEndpointLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEndpointLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMethodRateLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMethodRateLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMethodRateLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMethodRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateMethodRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMethodRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMethodRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMethodRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMethodRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMethodRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateMethodRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMethodRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchEndpointMetricResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  []EndpointMetric `json:"data"`
		Error *string          `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r FetchEndpointMetricResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEndpointMetricResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRateLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRateLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRateLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDomainMaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateDomainMaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDomainMaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDomainMaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDomainMaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDomainMaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *bool   `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJwtResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateJwtResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJwtResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJwtResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteJwtResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJwtResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReferrerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateReferrerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReferrerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReferrerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *bool   `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteReferrerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReferrerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRequestFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Id *string `json:"id,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateRequestFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRequestFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRequestFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRequestFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRequestFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRequestFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRequestFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRequestFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *bool   `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSecurityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSecurityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateSecurityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSecurityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEndpointStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *string `json:"data"`
		Error *string `json:"error"`
	}
	JSON400 *struct {
		Data  *bool  `json:"data"`
		Error string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateEndpointStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEndpointStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchAccountMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  []EndpointMetric `json:"data"`
		Error *string          `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r FetchAccountMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAccountMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			CreditsRemaining *int `json:"credits_remaining"`
			CreditsUsed      int  `json:"credits_used"`
			EndTime          int  `json:"end_time"`
			Limit            *int `json:"limit"`
			Overages         *int `json:"overages"`
			StartTime        int  `json:"start_time"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r UsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageByChainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Chains    *[]ChainUsage `json:"chains,omitempty"`
			EndTime   *int          `json:"end_time,omitempty"`
			StartTime *int          `json:"start_time,omitempty"`
		} `json:"data"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r UsageByChainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageByChainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageByEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			EndTime   *int             `json:"end_time,omitempty"`
			Endpoints *[]EndpointUsage `json:"endpoints,omitempty"`
			StartTime *int             `json:"start_time,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r UsageByEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageByEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageByMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			EndTime   *int           `json:"end_time,omitempty"`
			Methods   *[]MethodUsage `json:"methods,omitempty"`
			StartTime *int           `json:"start_time,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r UsageByMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageByMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// InvoicesWithResponse request returning *InvoicesResponse
func (c *ClientWithResponses) InvoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InvoicesResponse, error) {
	rsp, err := c.Invoices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvoicesResponse(rsp)
}

// PaymentsWithResponse request returning *PaymentsResponse
func (c *ClientWithResponses) PaymentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PaymentsResponse, error) {
	rsp, err := c.Payments(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePaymentsResponse(rsp)
}

// ChainsWithResponse request returning *ChainsResponse
func (c *ClientWithResponses) ChainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ChainsResponse, error) {
	rsp, err := c.Chains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChainsResponse(rsp)
}

// ListEndpointsWithResponse request returning *ListEndpointsResponse
func (c *ClientWithResponses) ListEndpointsWithResponse(ctx context.Context, params *ListEndpointsParams, reqEditors ...RequestEditorFn) (*ListEndpointsResponse, error) {
	rsp, err := c.ListEndpoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEndpointsResponse(rsp)
}

// CreateEndpointWithBodyWithResponse request with arbitrary body returning *CreateEndpointResponse
func (c *ClientWithResponses) CreateEndpointWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEndpointResponse, error) {
	rsp, err := c.CreateEndpointWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEndpointResponse(rsp)
}

func (c *ClientWithResponses) CreateEndpointWithResponse(ctx context.Context, body CreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEndpointResponse, error) {
	rsp, err := c.CreateEndpoint(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEndpointResponse(rsp)
}

// ArchiveEndpointWithResponse request returning *ArchiveEndpointResponse
func (c *ClientWithResponses) ArchiveEndpointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ArchiveEndpointResponse, error) {
	rsp, err := c.ArchiveEndpoint(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveEndpointResponse(rsp)
}

// ShowEndpointWithResponse request returning *ShowEndpointResponse
func (c *ClientWithResponses) ShowEndpointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ShowEndpointResponse, error) {
	rsp, err := c.ShowEndpoint(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowEndpointResponse(rsp)
}

// UpdateEndpointWithBodyWithResponse request with arbitrary body returning *UpdateEndpointResponse
func (c *ClientWithResponses) UpdateEndpointWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEndpointResponse, error) {
	rsp, err := c.UpdateEndpointWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEndpointResponse(rsp)
}

func (c *ClientWithResponses) UpdateEndpointWithResponse(ctx context.Context, id string, body UpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEndpointResponse, error) {
	rsp, err := c.UpdateEndpoint(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEndpointResponse(rsp)
}

// DisableMultichainWithResponse request returning *DisableMultichainResponse
func (c *ClientWithResponses) DisableMultichainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DisableMultichainResponse, error) {
	rsp, err := c.DisableMultichain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableMultichainResponse(rsp)
}

// EnableMultichainWithResponse request returning *EnableMultichainResponse
func (c *ClientWithResponses) EnableMultichainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*EnableMultichainResponse, error) {
	rsp, err := c.EnableMultichain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableMultichainResponse(rsp)
}

// DeleteIpCustomHeaderWithResponse request returning *DeleteIpCustomHeaderResponse
func (c *ClientWithResponses) DeleteIpCustomHeaderWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteIpCustomHeaderResponse, error) {
	rsp, err := c.DeleteIpCustomHeader(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIpCustomHeaderResponse(rsp)
}

// CreateOrUpdateIpCustomHeaderWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateIpCustomHeaderResponse
func (c *ClientWithResponses) CreateOrUpdateIpCustomHeaderWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateIpCustomHeaderResponse, error) {
	rsp, err := c.CreateOrUpdateIpCustomHeaderWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateIpCustomHeaderResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateIpCustomHeaderWithResponse(ctx context.Context, id string, body CreateOrUpdateIpCustomHeaderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateIpCustomHeaderResponse, error) {
	rsp, err := c.CreateOrUpdateIpCustomHeader(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateIpCustomHeaderResponse(rsp)
}

// GetLogDetailsWithResponse request returning *GetLogDetailsResponse
func (c *ClientWithResponses) GetLogDetailsWithResponse(ctx context.Context, id string, params *GetLogDetailsParams, reqEditors ...RequestEditorFn) (*GetLogDetailsResponse, error) {
	rsp, err := c.GetLogDetails(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogDetailsResponse(rsp)
}

// GetEndpointLogsWithResponse request returning *GetEndpointLogsResponse
func (c *ClientWithResponses) GetEndpointLogsWithResponse(ctx context.Context, id string, params *GetEndpointLogsParams, reqEditors ...RequestEditorFn) (*GetEndpointLogsResponse, error) {
	rsp, err := c.GetEndpointLogs(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEndpointLogsResponse(rsp)
}

// GetMethodRateLimitsWithResponse request returning *GetMethodRateLimitsResponse
func (c *ClientWithResponses) GetMethodRateLimitsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMethodRateLimitsResponse, error) {
	rsp, err := c.GetMethodRateLimits(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMethodRateLimitsResponse(rsp)
}

// CreateMethodRateLimitWithBodyWithResponse request with arbitrary body returning *CreateMethodRateLimitResponse
func (c *ClientWithResponses) CreateMethodRateLimitWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMethodRateLimitResponse, error) {
	rsp, err := c.CreateMethodRateLimitWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMethodRateLimitResponse(rsp)
}

func (c *ClientWithResponses) CreateMethodRateLimitWithResponse(ctx context.Context, id string, body CreateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMethodRateLimitResponse, error) {
	rsp, err := c.CreateMethodRateLimit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMethodRateLimitResponse(rsp)
}

// DeleteMethodRateLimitWithResponse request returning *DeleteMethodRateLimitResponse
func (c *ClientWithResponses) DeleteMethodRateLimitWithResponse(ctx context.Context, id string, methodRateLimitId string, reqEditors ...RequestEditorFn) (*DeleteMethodRateLimitResponse, error) {
	rsp, err := c.DeleteMethodRateLimit(ctx, id, methodRateLimitId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMethodRateLimitResponse(rsp)
}

// UpdateMethodRateLimitWithBodyWithResponse request with arbitrary body returning *UpdateMethodRateLimitResponse
func (c *ClientWithResponses) UpdateMethodRateLimitWithBodyWithResponse(ctx context.Context, id string, methodRateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMethodRateLimitResponse, error) {
	rsp, err := c.UpdateMethodRateLimitWithBody(ctx, id, methodRateLimitId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMethodRateLimitResponse(rsp)
}

func (c *ClientWithResponses) UpdateMethodRateLimitWithResponse(ctx context.Context, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMethodRateLimitResponse, error) {
	rsp, err := c.UpdateMethodRateLimit(ctx, id, methodRateLimitId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMethodRateLimitResponse(rsp)
}

// FetchEndpointMetricWithResponse request returning *FetchEndpointMetricResponse
func (c *ClientWithResponses) FetchEndpointMetricWithResponse(ctx context.Context, id string, params *FetchEndpointMetricParams, reqEditors ...RequestEditorFn) (*FetchEndpointMetricResponse, error) {
	rsp, err := c.FetchEndpointMetric(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchEndpointMetricResponse(rsp)
}

// UpdateRateLimitsWithBodyWithResponse request with arbitrary body returning *UpdateRateLimitsResponse
func (c *ClientWithResponses) UpdateRateLimitsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRateLimitsResponse, error) {
	rsp, err := c.UpdateRateLimitsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRateLimitsResponse(rsp)
}

func (c *ClientWithResponses) UpdateRateLimitsWithResponse(ctx context.Context, id string, body UpdateRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRateLimitsResponse, error) {
	rsp, err := c.UpdateRateLimits(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRateLimitsResponse(rsp)
}

// CreateDomainMaskWithBodyWithResponse request with arbitrary body returning *CreateDomainMaskResponse
func (c *ClientWithResponses) CreateDomainMaskWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainMaskResponse, error) {
	rsp, err := c.CreateDomainMaskWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainMaskResponse(rsp)
}

func (c *ClientWithResponses) CreateDomainMaskWithResponse(ctx context.Context, id string, body CreateDomainMaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainMaskResponse, error) {
	rsp, err := c.CreateDomainMask(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainMaskResponse(rsp)
}

// DeleteDomainMaskWithResponse request returning *DeleteDomainMaskResponse
func (c *ClientWithResponses) DeleteDomainMaskWithResponse(ctx context.Context, id string, domainMaskId string, reqEditors ...RequestEditorFn) (*DeleteDomainMaskResponse, error) {
	rsp, err := c.DeleteDomainMask(ctx, id, domainMaskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDomainMaskResponse(rsp)
}

// CreateIpWithBodyWithResponse request with arbitrary body returning *CreateIpResponse
func (c *ClientWithResponses) CreateIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpResponse, error) {
	rsp, err := c.CreateIpWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpResponse(rsp)
}

func (c *ClientWithResponses) CreateIpWithResponse(ctx context.Context, id string, body CreateIpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpResponse, error) {
	rsp, err := c.CreateIp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpResponse(rsp)
}

// DeleteIpWithResponse request returning *DeleteIpResponse
func (c *ClientWithResponses) DeleteIpWithResponse(ctx context.Context, id string, ipId string, reqEditors ...RequestEditorFn) (*DeleteIpResponse, error) {
	rsp, err := c.DeleteIp(ctx, id, ipId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIpResponse(rsp)
}

// CreateJwtWithBodyWithResponse request with arbitrary body returning *CreateJwtResponse
func (c *ClientWithResponses) CreateJwtWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJwtResponse, error) {
	rsp, err := c.CreateJwtWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJwtResponse(rsp)
}

func (c *ClientWithResponses) CreateJwtWithResponse(ctx context.Context, id string, body CreateJwtJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJwtResponse, error) {
	rsp, err := c.CreateJwt(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJwtResponse(rsp)
}

// DeleteJwtWithResponse request returning *DeleteJwtResponse
func (c *ClientWithResponses) DeleteJwtWithResponse(ctx context.Context, id string, jwtId string, reqEditors ...RequestEditorFn) (*DeleteJwtResponse, error) {
	rsp, err := c.DeleteJwt(ctx, id, jwtId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJwtResponse(rsp)
}

// CreateReferrerWithBodyWithResponse request with arbitrary body returning *CreateReferrerResponse
func (c *ClientWithResponses) CreateReferrerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReferrerResponse, error) {
	rsp, err := c.CreateReferrerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReferrerResponse(rsp)
}

func (c *ClientWithResponses) CreateReferrerWithResponse(ctx context.Context, id string, body CreateReferrerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReferrerResponse, error) {
	rsp, err := c.CreateReferrer(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReferrerResponse(rsp)
}

// DeleteReferrerWithResponse request returning *DeleteReferrerResponse
func (c *ClientWithResponses) DeleteReferrerWithResponse(ctx context.Context, id string, referrerId string, reqEditors ...RequestEditorFn) (*DeleteReferrerResponse, error) {
	rsp, err := c.DeleteReferrer(ctx, id, referrerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReferrerResponse(rsp)
}

// CreateRequestFilterWithBodyWithResponse request with arbitrary body returning *CreateRequestFilterResponse
func (c *ClientWithResponses) CreateRequestFilterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequestFilterResponse, error) {
	rsp, err := c.CreateRequestFilterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequestFilterResponse(rsp)
}

func (c *ClientWithResponses) CreateRequestFilterWithResponse(ctx context.Context, id string, body CreateRequestFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequestFilterResponse, error) {
	rsp, err := c.CreateRequestFilter(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequestFilterResponse(rsp)
}

// DeleteRequestFilterWithResponse request returning *DeleteRequestFilterResponse
func (c *ClientWithResponses) DeleteRequestFilterWithResponse(ctx context.Context, id string, requestFilterId string, reqEditors ...RequestEditorFn) (*DeleteRequestFilterResponse, error) {
	rsp, err := c.DeleteRequestFilter(ctx, id, requestFilterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRequestFilterResponse(rsp)
}

// UpdateRequestFilterWithBodyWithResponse request with arbitrary body returning *UpdateRequestFilterResponse
func (c *ClientWithResponses) UpdateRequestFilterWithBodyWithResponse(ctx context.Context, id string, requestFilterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequestFilterResponse, error) {
	rsp, err := c.UpdateRequestFilterWithBody(ctx, id, requestFilterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRequestFilterResponse(rsp)
}

func (c *ClientWithResponses) UpdateRequestFilterWithResponse(ctx context.Context, id string, requestFilterId string, body UpdateRequestFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRequestFilterResponse, error) {
	rsp, err := c.UpdateRequestFilter(ctx, id, requestFilterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRequestFilterResponse(rsp)
}

// CreateAuthenticationTokenWithResponse request returning *CreateAuthenticationTokenResponse
func (c *ClientWithResponses) CreateAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CreateAuthenticationTokenResponse, error) {
	rsp, err := c.CreateAuthenticationToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthenticationTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, id string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, id, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// GetSecurityOptionsWithResponse request returning *GetSecurityOptionsResponse
func (c *ClientWithResponses) GetSecurityOptionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSecurityOptionsResponse, error) {
	rsp, err := c.GetSecurityOptions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityOptionsResponse(rsp)
}

// UpdateSecurityOptionsWithBodyWithResponse request with arbitrary body returning *UpdateSecurityOptionsResponse
func (c *ClientWithResponses) UpdateSecurityOptionsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSecurityOptionsResponse, error) {
	rsp, err := c.UpdateSecurityOptionsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSecurityOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateSecurityOptionsWithResponse(ctx context.Context, id string, body UpdateSecurityOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSecurityOptionsResponse, error) {
	rsp, err := c.UpdateSecurityOptions(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSecurityOptionsResponse(rsp)
}

// UpdateEndpointStatusWithBodyWithResponse request with arbitrary body returning *UpdateEndpointStatusResponse
func (c *ClientWithResponses) UpdateEndpointStatusWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEndpointStatusResponse, error) {
	rsp, err := c.UpdateEndpointStatusWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEndpointStatusResponse(rsp)
}

func (c *ClientWithResponses) UpdateEndpointStatusWithResponse(ctx context.Context, id string, body UpdateEndpointStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEndpointStatusResponse, error) {
	rsp, err := c.UpdateEndpointStatus(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEndpointStatusResponse(rsp)
}

// CreateTagWithBodyWithResponse request with arbitrary body returning *CreateTagResponse
func (c *ClientWithResponses) CreateTagWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTagWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

func (c *ClientWithResponses) CreateTagWithResponse(ctx context.Context, id string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTag(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

// FetchAccountMetricsWithResponse request returning *FetchAccountMetricsResponse
func (c *ClientWithResponses) FetchAccountMetricsWithResponse(ctx context.Context, params *FetchAccountMetricsParams, reqEditors ...RequestEditorFn) (*FetchAccountMetricsResponse, error) {
	rsp, err := c.FetchAccountMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchAccountMetricsResponse(rsp)
}

// UsageWithResponse request returning *UsageResponse
func (c *ClientWithResponses) UsageWithResponse(ctx context.Context, params *UsageParams, reqEditors ...RequestEditorFn) (*UsageResponse, error) {
	rsp, err := c.Usage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageResponse(rsp)
}

// UsageByChainWithResponse request returning *UsageByChainResponse
func (c *ClientWithResponses) UsageByChainWithResponse(ctx context.Context, params *UsageByChainParams, reqEditors ...RequestEditorFn) (*UsageByChainResponse, error) {
	rsp, err := c.UsageByChain(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageByChainResponse(rsp)
}

// UsageByEndpointWithResponse request returning *UsageByEndpointResponse
func (c *ClientWithResponses) UsageByEndpointWithResponse(ctx context.Context, params *UsageByEndpointParams, reqEditors ...RequestEditorFn) (*UsageByEndpointResponse, error) {
	rsp, err := c.UsageByEndpoint(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageByEndpointResponse(rsp)
}

// UsageByMethodWithResponse request returning *UsageByMethodResponse
func (c *ClientWithResponses) UsageByMethodWithResponse(ctx context.Context, params *UsageByMethodParams, reqEditors ...RequestEditorFn) (*UsageByMethodResponse, error) {
	rsp, err := c.UsageByMethod(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageByMethodResponse(rsp)
}

// ParseInvoicesResponse parses an HTTP response from a InvoicesWithResponse call
func ParseInvoicesResponse(rsp *http.Response) (*InvoicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Invoices *[]Invoice `json:"invoices,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePaymentsResponse parses an HTTP response from a PaymentsWithResponse call
func ParsePaymentsResponse(rsp *http.Response) (*PaymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PaymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Payments *[]Payment `json:"payments,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChainsResponse parses an HTTP response from a ChainsWithResponse call
func ParseChainsResponse(rsp *http.Response) (*ChainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  []Chain `json:"data"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEndpointsResponse parses an HTTP response from a ListEndpointsWithResponse call
func ParseListEndpointsResponse(rsp *http.Response) (*ListEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *[]Endpoint `json:"data"`
			Error *string     `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEndpointResponse parses an HTTP response from a CreateEndpointWithResponse call
func ParseCreateEndpointResponse(rsp *http.Response) (*CreateEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  SingleEndpoint `json:"data"`
			Error *string        `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveEndpointResponse parses an HTTP response from a ArchiveEndpointWithResponse call
func ParseArchiveEndpointResponse(rsp *http.Response) (*ArchiveEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseShowEndpointResponse parses an HTTP response from a ShowEndpointWithResponse call
func ParseShowEndpointResponse(rsp *http.Response) (*ShowEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *SingleEndpoint `json:"data,omitempty"`
			Error *string         `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateEndpointResponse parses an HTTP response from a UpdateEndpointWithResponse call
func ParseUpdateEndpointResponse(rsp *http.Response) (*UpdateEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisableMultichainResponse parses an HTTP response from a DisableMultichainWithResponse call
func ParseDisableMultichainResponse(rsp *http.Response) (*DisableMultichainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableMultichainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnableMultichainResponse parses an HTTP response from a EnableMultichainWithResponse call
func ParseEnableMultichainResponse(rsp *http.Response) (*EnableMultichainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableMultichainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteIpCustomHeaderResponse parses an HTTP response from a DeleteIpCustomHeaderWithResponse call
func ParseDeleteIpCustomHeaderResponse(rsp *http.Response) (*DeleteIpCustomHeaderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIpCustomHeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *bool   `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateIpCustomHeaderResponse parses an HTTP response from a CreateOrUpdateIpCustomHeaderWithResponse call
func ParseCreateOrUpdateIpCustomHeaderResponse(rsp *http.Response) (*CreateOrUpdateIpCustomHeaderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateIpCustomHeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				HeaderName *string `json:"header_name,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLogDetailsResponse parses an HTTP response from a GetLogDetailsWithResponse call
func ParseGetLogDetailsResponse(rsp *http.Response) (*GetLogDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEndpointLogsResponse parses an HTTP response from a GetEndpointLogsWithResponse call
func ParseGetEndpointLogsResponse(rsp *http.Response) (*GetEndpointLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEndpointLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMethodRateLimitsResponse parses an HTTP response from a GetMethodRateLimitsWithResponse call
func ParseGetMethodRateLimitsResponse(rsp *http.Response) (*GetMethodRateLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMethodRateLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateMethodRateLimitResponse parses an HTTP response from a CreateMethodRateLimitWithResponse call
func ParseCreateMethodRateLimitResponse(rsp *http.Response) (*CreateMethodRateLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMethodRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteMethodRateLimitResponse parses an HTTP response from a DeleteMethodRateLimitWithResponse call
func ParseDeleteMethodRateLimitResponse(rsp *http.Response) (*DeleteMethodRateLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMethodRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateMethodRateLimitResponse parses an HTTP response from a UpdateMethodRateLimitWithResponse call
func ParseUpdateMethodRateLimitResponse(rsp *http.Response) (*UpdateMethodRateLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMethodRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFetchEndpointMetricResponse parses an HTTP response from a FetchEndpointMetricWithResponse call
func ParseFetchEndpointMetricResponse(rsp *http.Response) (*FetchEndpointMetricResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchEndpointMetricResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  []EndpointMetric `json:"data"`
			Error *string          `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRateLimitsResponse parses an HTTP response from a UpdateRateLimitsWithResponse call
func ParseUpdateRateLimitsResponse(rsp *http.Response) (*UpdateRateLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRateLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateDomainMaskResponse parses an HTTP response from a CreateDomainMaskWithResponse call
func ParseCreateDomainMaskResponse(rsp *http.Response) (*CreateDomainMaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDomainMaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDomainMaskResponse parses an HTTP response from a DeleteDomainMaskWithResponse call
func ParseDeleteDomainMaskResponse(rsp *http.Response) (*DeleteDomainMaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDomainMaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateIpResponse parses an HTTP response from a CreateIpWithResponse call
func ParseCreateIpResponse(rsp *http.Response) (*CreateIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteIpResponse parses an HTTP response from a DeleteIpWithResponse call
func ParseDeleteIpResponse(rsp *http.Response) (*DeleteIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *bool   `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateJwtResponse parses an HTTP response from a CreateJwtWithResponse call
func ParseCreateJwtResponse(rsp *http.Response) (*CreateJwtResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJwtResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteJwtResponse parses an HTTP response from a DeleteJwtWithResponse call
func ParseDeleteJwtResponse(rsp *http.Response) (*DeleteJwtResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJwtResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateReferrerResponse parses an HTTP response from a CreateReferrerWithResponse call
func ParseCreateReferrerResponse(rsp *http.Response) (*CreateReferrerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReferrerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteReferrerResponse parses an HTTP response from a DeleteReferrerWithResponse call
func ParseDeleteReferrerResponse(rsp *http.Response) (*DeleteReferrerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReferrerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *bool   `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRequestFilterResponse parses an HTTP response from a CreateRequestFilterWithResponse call
func ParseCreateRequestFilterResponse(rsp *http.Response) (*CreateRequestFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRequestFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Id *string `json:"id,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRequestFilterResponse parses an HTTP response from a DeleteRequestFilterWithResponse call
func ParseDeleteRequestFilterResponse(rsp *http.Response) (*DeleteRequestFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRequestFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateRequestFilterResponse parses an HTTP response from a UpdateRequestFilterWithResponse call
func ParseUpdateRequestFilterResponse(rsp *http.Response) (*UpdateRequestFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRequestFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateAuthenticationTokenResponse parses an HTTP response from a CreateAuthenticationTokenWithResponse call
func ParseCreateAuthenticationTokenResponse(rsp *http.Response) (*CreateAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *bool   `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSecurityOptionsResponse parses an HTTP response from a GetSecurityOptionsWithResponse call
func ParseGetSecurityOptionsResponse(rsp *http.Response) (*GetSecurityOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateSecurityOptionsResponse parses an HTTP response from a UpdateSecurityOptionsWithResponse call
func ParseUpdateSecurityOptionsResponse(rsp *http.Response) (*UpdateSecurityOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSecurityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateEndpointStatusResponse parses an HTTP response from a UpdateEndpointStatusWithResponse call
func ParseUpdateEndpointStatusResponse(rsp *http.Response) (*UpdateEndpointStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEndpointStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *string `json:"data"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Data  *bool  `json:"data"`
			Error string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateTagResponse parses an HTTP response from a CreateTagWithResponse call
func ParseCreateTagResponse(rsp *http.Response) (*CreateTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFetchAccountMetricsResponse parses an HTTP response from a FetchAccountMetricsWithResponse call
func ParseFetchAccountMetricsResponse(rsp *http.Response) (*FetchAccountMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchAccountMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  []EndpointMetric `json:"data"`
			Error *string          `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsageResponse parses an HTTP response from a UsageWithResponse call
func ParseUsageResponse(rsp *http.Response) (*UsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				CreditsRemaining *int `json:"credits_remaining"`
				CreditsUsed      int  `json:"credits_used"`
				EndTime          int  `json:"end_time"`
				Limit            *int `json:"limit"`
				Overages         *int `json:"overages"`
				StartTime        int  `json:"start_time"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsageByChainResponse parses an HTTP response from a UsageByChainWithResponse call
func ParseUsageByChainResponse(rsp *http.Response) (*UsageByChainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageByChainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Chains    *[]ChainUsage `json:"chains,omitempty"`
				EndTime   *int          `json:"end_time,omitempty"`
				StartTime *int          `json:"start_time,omitempty"`
			} `json:"data"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsageByEndpointResponse parses an HTTP response from a UsageByEndpointWithResponse call
func ParseUsageByEndpointResponse(rsp *http.Response) (*UsageByEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageByEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				EndTime   *int             `json:"end_time,omitempty"`
				Endpoints *[]EndpointUsage `json:"endpoints,omitempty"`
				StartTime *int             `json:"start_time,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsageByMethodResponse parses an HTTP response from a UsageByMethodWithResponse call
func ParseUsageByMethodResponse(rsp *http.Response) (*UsageByMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageByMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				EndTime   *int           `json:"end_time,omitempty"`
				Methods   *[]MethodUsage `json:"methods,omitempty"`
				StartTime *int           `json:"start_time,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xdW3PbOJb+KyzuPsoxAII3V+2Dk7h7MttOZxLPTHXHLhUIHEhMJFJNUna8Lv/3LRCk",
	"SImkSEm+dY/9YpsEDoFzvnPD9c7k8XwRRxBlqXlyZ6Z8CnOW/8mnLIzUH4skXkCShZA/DtNxCjPg2XhV",
	"ILtdgHliBnE8AxaZ9yMzguwmTr7rChnM8z/+OwFpnpj/dVx98rj43nFRQdUtqLEkYbfq/3S2nNS+kmZJ",
	"GE3M+6pkHHwDnqmieYvGy5RNoNlwnoAIs3S8TEHU6IVRBhNI8lazOQz8EkRiEYdR1vKZkisCUp6EiyyM",
	"I/NEPzbyvoxM+MHmi5miCNnUHG1+cGROs2wxXiazltaMzFC0Pp6xAPIK0XI2Y4EinyVLaKFeMrvRyOJF",
	"s5lzFkYRZG1NzdhkXczr7Fi1qq3iOGyVRBvDN1Fxk6Ylg3r6ez8yE/hjGSZK7F8V9wqgmBUnahy/2iLt",
	"sYgVJ8Zzln5vdlW/HC6ybbgah4sW1WsXvC66C/FvN9lg6t87nncoy8hcLINZyMff4XbXZs0hS0LewliW",
	"sTWIrf5o6vAmThr/s8muzUpYBuNZOA+zFnwzzuOltgMdOKw1rqI0Dm4LEXfUqhnTZCEGkl/MhxZMhxTc",
	"zhWQkCSQDAZSvcJO7Ic/lpBmYxnOsh0+N4dsGos2tNRM0AY4Fixha0XL5mxtYAp8mYTZbZdFyM3FcFfY",
	"amxaGhsu9qAZLtpIfbvJ9qClrEgLsTj3JmkXN85LZvQDP1y8W6ZZPP8bMNEm+Ws2W8IwD9CQXrgY2IiS",
	"NwP0tAD44OI5rn/KYT2wThZ/h2hQ2bY+rzVwN1mvlLdF4OsKuhfxNQ1vs9qrfu9GOa/XJLhVnXWdoWZm",
	"VXoXk9YVoU674of+2HV49KcNYzoOEmDfRXwTDWarrlm0vkVKnSFBLeBscQu58DvceZqxbJkO5G8YXcch",
	"b2EsmysfPRZLaP9K8X7Bwg7uBuFsFkaTcQIsjTtFxLIu6XSF7GEE24Jn3a52kmuR+yD2NLwdJGEsxhB1",
	"NLp4n2YsyXaUzshMl0EWZ2w2NL5fw1aTEQmfhtcwzEgeokZFM/ZAclunaqVbNL3IfvrDtc7W7JAaL9jt",
	"HNry1QbGauxiiRjPWJqN6SDLUqjAmHWQWyYJRPy2PVxjyXfIFjPGYVw1qZ83OxmINIwmMxi/Ju8r47ue",
	"2gzz1rU6iqe16HdQ/VWF7QbkrzauUONUc4ihxscvil+Fai7CMo1WqDSnOg4uDYL544gtwiNVourHIvxf",
	"yDsSAEsgGbNlNlUE9L8/xclcaaf5939fqBbl31LWM39bkVGtNu9Vs6Zxqsrf3Ny8+WMZ8u9RLOANj+em",
	"crcyzpUmjjLGtb7qhv1DlfwYC2g4quqV8S6O0ngGxumnD8a/kPp2mOV4XT24hiTVta6RziwgYovQPDGt",
	"N+gNNpVVy6Y5q46v0XHhpI+LMCB/PoGsqSmfIUtCuAZjFqaZEUtjVSP/RsJUuQ/CPDE/VC8SSBdxlGqy",
	"BKGy54VRZYvFLOR5zeNvRYygod89nrERYNaaPSgcK8OdYeFtksTJXrnSfUOG6ZJzSFMN2+V8zpLbGlfT",
	"NrZqbf5qvtUyMq9U3brQCv+0g9BWNTaF9ql68ehCqzd7kNBKP/xihVZja6fQcjPXLaqfIONTg61IFsU3",
	"5fSufPwIUhokC22tW5zADnyvu4D842Xtq71lotnXYF4pjYJtK2GUjnWA6qyK5tQbAvklTLOzFbViOAx0",
	"Tv+18EF/LCG5rVxQHgeUnoS1O932mrGUKexXVXv4dK3u4CHhbUTzoGI73a7Bw/ur58PxKp5V4WE7Yl8I",
	"tCtz04BiCe8KgFcqbcnDj01Av8sTDYMZOqBfEWuamLzgWfW6GG14G4vbA6TTnWHukh+u81hJ4f5RMLQN",
	"OpsZ0bMjREssNZgRwU1dsG342LSAx3ehuNdwmUEGTeCc6nGEAcgpStag02YNVfxZmZA8BViXaIt5W/Gv",
	"w2IM4VLZjx7+jDr9wTKJ0gFc+DKNb56BBS8W8HuCWrGxhdcdJo9lfNoU2j8XQtm83EUZMk4GSE9XeXT5",
	"PYRF7Urn23h+v7/eFEzcx6wcizBV4BjPl7MsrBbHtDqo97psatQKb0qnKHNeL/GSbEzRvloXctht4Z3x",
	"ZTXC0cFDiAaz8Czq5aAu8mIZqJv3oPwLF2OeT4mOp6s50S5f9z5/bmRTMD58MnQ1YzWEtIHFvOyH9fnW",
	"P429b04BPL5J1xxLu9i7TbSdJr4Ia+PEWGo7xaJ+0elKvybatD2RCB/C5Ov+rKZa1lmx2W0jL9YXg9ZJ",
	"Xj1bvL21m0OmiR8dvBorqUIaL+PtaFcYt1uoWTwZC8hYOOsfj0gNXRKEEUYyH5oO46gMbhbAQxlyYxZP",
	"DIiyPFdfh/7PkP0ST94XX3sErHcMFZTrFZ7E+BXzODpKqpg7LkmtLYQpIVi00Dwx7y5NRSlZ8EvzxLg0",
	"yRt0aY6My2KmUz+EbDrmbDbTb/QqKPXm692lmcW6DPrhEP5OenDmubbDXO4gQt5h9C5wzgA77k+UIOG5",
	"p8TWVGQSz8uaPCDUoqfYtciZ8B1yhjglFvFti2MLzsBxsS+ltHTNvDdl1aK1qmOrdjDXwQQR1PHDiOXx",
	"AAJMCccIpMuERynhjsDSB88H5ILrOhg95w+mB1NArz9P/0MOlRunnvCQlIgd2JAD2+H6CDk+BYcEQrpS",
	"2hgxCuA4jkO4pJ7jMN/BzMKObT03y+3AohAwJLkAYMj3kRTIdaTFOfORgwMJAbcQAar+wMxhEPicu4BR",
	"4Fo2JZR7AQ/sF4AfjChxmAMYfGy5HmVAbGCOgwUSPKAcsBUEwveR41vcgoCJADEPlDhk4AVYCJtgmwjX",
	"o5ZLAt8iiLmOZI4UgY2kgxFGLpFYIpu5ngeKpIsD7iPmYmLbBCjmgAObQOC6iqRvgwwgIDbGxPdti4JP",
	"AuH5WPqOTwWnWDiOHwClDlVFqBQuER4nyHY4lS5Gji184bOAq+9bwMCTNrccsIR0LYmZJzzLk4GP3UDY",
	"wvIFDuyAWBYSAvmeENQLqCWk7YpABJh5PKCEeMSlyCHgY3AEBcltDIIIWxCHMdU/5LmES+76gWMh4DYT",
	"gU8tCRalPmaOG3DPCygOmMTgOo7LuceozxDjHAvMfdfyqSSM+wEn1BeWDci3MMbS8pEjCfHBdn3L5UAw",
	"owFg6kpbguVL4jsUkC0cgQRYxKfcoURQ2+fCZ4xw4YFNJXiYgeU7jDGfU0II9yzh2NT2XJe7xMV8Xwhd",
	"mvej3BESWzqecC7NK/V/mDtzi+D72pTaZgRQBgBFcYvg0aUOOC/Nk7tLk8dCuV5rpAKENGUTyCvBD+DL",
	"PDhL4BqSDMSJ8fMXRJycVOGcc3ftccv1GXpe24Zs6tqWhSxiOXvz+P7yMsqHm5pRtQpJizjMSIpgVhhF",
	"rC2Xs1k+1ULbhgrC6JrNQmFUMaShI19dgzZrlAG2EcWZIeNlJDai+Z8hS41ak9ri9l/iSbotZh8SrKti",
	"m8F559jjz7CaSsy//XTReRjx2VLAuOJGg0RtlfRDT2tG8CMbs9a6fQ1XEfNDMCCLnz4t2ZqPfFWYWqWE",
	"e+QmKUTiM7u5SFiUMq7a0chUcuNDpI9sbDnUI9S2LY9agc84Q8hTkU1APIQ8y/d8x0M+dXyOHMeXVmAL",
	"iSQB4lAqEUa+F1Dq2NJ2bIIR9lDgI8roa9rxmnY8+8++/mwlPXgZ6Qf2CUK2TTgwN+CWxYMAAl9i4SMV",
	"nWGh9IaBlAI9d/rBKfVtGgQSUxIAtmzKfCQQZ9hDVDKb2b4dCMdBggO4lKsgjwYEu7bPsLQlkp5vuSD5",
	"gSzzOt/4vidAMimQTz3sgrSILx3BXZ+7yJKYS+ypDOAw5HF5KGIsKij3OGFICMylxSgg6VucSy8Q2LKY",
	"bdvYsz0IHAtzIqUIqO8xggPkUGHxP1/CisDBwgPPx2Bb2PGFsC2E3UASFzwbELiEYk8yL+AI+x5AYGHf",
	"R4LbAts28BdnfzCirrRclTzZjmMxF6iNPF8ElHAmfRIEniu57TiuCBhyCbJtHwJqOTLwkfSpw8G2HYuI",
	"gFvYwZaUlguWq3KYQVlLAulylhXJhkUd5acB29gTFiOCI0ZtCTbmzEI2QaqZros8SSjhyLE4sR2OLewR",
	"LgmmVR6E7lcD72OVApkn0XI2K1ZvlztJzU+/frkwq52lHaFJbfn3iflDsLBadpSvSzdlAJxJ7h0RKp0j",
	"jCU6CiyEjqhHA8wodpglzWptPEFoZGbhHNKMzRfmiUkQsY8QPSL+BSYnln9C7Dc2tX43R2a+ct08NlVo",
	"eFjI1T8cfEb9d2+Rh8ETvuMT9M7y2Kl7+tZHPEDEpyygb7l3dtocwEWEeZwdHkgUifCMZZBma1nwwBy4",
	"mfgeWQRheyP7/de5USXAeZ0363nv5eUSIXSmfrm++5v+F/3lf5n3pf7ghv4UjBygQQpp/TrjIMsTnNV1",
	"hghvf53B9huHuGs6czVaZW8n5vkFRx8vvv/f+ftz/PHit5tfL05vzt+f3pz/7cf847fTm9/fT378/gXd",
	"fvz5N/LLxdmP37+dZr99+/v3j7fI+vXiHze/z8/I+XtOPv77/H/MrkGEvUcParn0YcMGq1IznaTvNnCg",
	"5XiUsAyOql1ErcMI+dd0eSPJFzLp8i3jBud5qc8sg1/KMi9kIUI96a22QUGSjvNFrK0zcfVieeNXG0UV",
	"KOkRwkcIK1AidILQG23ZFC5z3DMcEG4JegS2dI4os4Mjn3viyAVH2owGFici34qTQXLNFJBT4HEkVkqW",
	"S7Nod6mHV3rjl3mCUaUypl6bI8z7q2oOWnnBVvBWy3clZHyqqnXgMCkWG8J8kd0aN1OIKtCJGNIcn/BD",
	"8a8Fn62IaYBUYcUowNK3ajg1WJNqx6qKDSS+6OUUFQTuTIiWc8WgCgthtMzAHJmC1befNTaF73ZchgZR",
	"6z67tZ1xZcuqzxR1r4av7ttBM0u0F1vnGir54hWwX/0aADbKTj2F59iuSD3aOdSTHN8Ve7Frh+b0rO4u",
	"12QNUXBd9gkUfNRKpK1vz+jAxjlLi6MENhTG/FyhTHN+I1jZB64FoU4MNmt0gXG70PtdxbbV1sOgpMv+",
	"yaH0EC7oQZ1IfXN46c9KCzkyi8XYosWZ3T+KUyn2DdSV5jmci/LfWzzLGFc7/8tHpHI31oO5G71AVQyd",
	"5uyODvsVfLsq7uttkpD3bGCF2gYZXUFPfkbdk555vbIl5/o0u4Yd2FzmXrT7w/tc0g9gI9Y/MI2XycgQ",
	"7HZk3AB8HxnzOMrpt00d6iNftn6w1EVFtwgoR6airHCZk25TyXb7nuf+6Ti+hmSssvWRUWrpWMO0/qpW",
	"pTq7qFmj9qq0jGUJRWc8Zz9Gq9n3HPhrX8kPrRl3ve9g27wUdT/b2jteG61q9Hyl7xtdb6lTf9fV+drI",
	"SkvverrfItoXsO+1PDjyhe7kXrMhbSbrvDBHXeZqY3xlscw6t4fVEmUjjrYaK13jCYZZHiK02DioZh5G",
	"n2rv8Wiz+KLjfKfiiMzOIzH7j4zZQEq9YVf7blb7XJNan2d9y4TxucernrVkcCPTbiP3QcUWEZsZXyC5",
	"hsQ4yyHf7oF3GoVph3J5ys3x5tGY2zd6r40ZVadito/avF+dM/miIb1xlvDDbRfff5v1BnN33/3RKt7j",
	"u9p/g3P4SA8KhtFks3lGq+x1xceVfXsCtt67J9ue2c+oB5BjcUzqYO0MFx1K+WHxskdPFy9GB3MWHiay",
	"47twcZCitYix3CL6dHqV9+E/fHtpt3QOQEh5pPFgrf520zVD8veblz0r8tin1z+FQdDcP1Dex3ffbrKD",
	"bEIbCHSFRwJBu1XQ3XgRXvZgwawdyD1YG1dncber5Ofq9QvO53a5DGBPJSu/Uc2NDdG2GncfQrLHd+Wf",
	"Bylfp8x1rceUebsa1nr16qK3yusgFDVO1t/BSuR1jeJQ/S5bUbuD4EUbjOo6j80TvRJ2a8SynBxQzdS7",
	"lG6mYQYzLRhzNPwgvxdybsTwK4MeHemdlnIDYQ+HdGU16w8OtJ1bNaG0oI+sCV1mdKObBxpT2hnYGEdG",
	"FBslRHcyZTuIebR1dHoH+1SMTv9ppfIfYPP2w9pqOvdgrPWYlOrOmME+ky2zKURZIR9D3+3S7jlP14pe",
	"FCVf0vFjHVa7o48HM/r4Lv99kKVuZ7iu8mgsbjcBZWdeg9tuMe2PmXHtkrDu5eJlaaMo3bv+4mfIyib8",
	"WnzgRa4d32RD1/Lxr3fFbWolIFOzdQFPrVg1pNBXMh8F7CsULvrL1O916ys7TQd8lMfJkI6uXZ/W35GN",
	"g/EaxUcl9813Px29i6MIuIL90YdP+daQvjVSTbD2LIwftkFjk+y+ZwuWbndnndIVn0qtHiJsqtkWJkSo",
	"/mGz+nIByWYpbC4ZyEG361rD0ealhjvWnhYXn+1YrXkx4s4E9vlsOW+wY7W1Uc6d625ekrgjgSoKPHQR",
	"6fq6jxJkj7OFoVgEMm7zl68+4q/jIx5qGW2vL+ky//tFcauF2R3O5hNbpvk5toxn4fVGltVzTPkXTfwl",
	"O5jmwvS8n5A3Or9b8KpvgWFB4uGsR18S0Xuv3JOvlFxB/nF61pYuPXBXct1k1a7w7YfNG2mJ7OFnzpeX",
	"4G0dwcjYpG+tpy55wSZ/mUsA9poRvGCT3o1y+66vbB17qVLmnPUNU3vB6rurh25LKMoZbDJJYKJ6YzCe",
	"xGlqsNmsdrNOEdqXV9S37lY41S/LJcg9uxVeNxO8biZ4zM0EDdF+goRDlIUzyNFcNsBQBEo96IZfUdV8",
	"+jG7P9v+he2iKvcutO1uKKzL0QyuYVYTSWnrCgPT3OSQX/V8nCx4p737II388mndBn13hv6bJWDMwzQN",
	"o8nI0PcKZ0ZxlaSh7Y4RpoaKxQwWqfhZpR/qZXEFdI6mbAplYUVQn1QA4k0zQs1vpe6xjV9UU40til31",
	"pfdkyYa72Ua35Mp2qldPMGdd3q+9YvewO5z7r+VedfHkzpTlHbbV+S5tRPUGwUHfVzhnE92FQTdOl2Ic",
	"2poN7Vzr72gdF6ueXj3VVH9P6pnrW8KiCXTe5ZdrsnZ2uV4Vp8PCWuXKImhtatqB4+D2aHUpUM9ZtPqT",
	"CoVGcGu0Xw+Uf+ft7bv2q4FelbftUsN0t8tTi/v62xzX7hq7n2IdoiQPnMgeqECbaB6iL/Wr7HdSme7R",
	"GK013bfGvSrOxtM9oL52Z+9usWKnxj29+jyfirRcorZNS6qFNMN1ZJLEywUI9bWieoemnJdvX/XkwfWk",
	"7USRbVpS5KmvOtKG3oamKDLlWL9CbAAsgWTMltnUPPl6paDGFqHeC/P1SmEkzTcJa3zrcxOnWbZIT46P",
	"2SJ888cy5N+jWMAbHs/zCZHik3clGP9ZCGb1oBoCrT0sbjhvKVbNTdReltfTt5Wv70lue19mpfdX9/8f",
	"AAD//4PMuTcLlwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
