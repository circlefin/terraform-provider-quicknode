// Package quicknode provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package quicknode

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	Api_keyScopes     = "api_key.Scopes"
	Bearer_authScopes = "bearer_auth.Scopes"
)

// Defines values for CreateMethodRateLimitJSONBodyInterval.
const (
	CreateMethodRateLimitJSONBodyIntervalDay    CreateMethodRateLimitJSONBodyInterval = "day"
	CreateMethodRateLimitJSONBodyIntervalMinute CreateMethodRateLimitJSONBodyInterval = "minute"
	CreateMethodRateLimitJSONBodyIntervalSecond CreateMethodRateLimitJSONBodyInterval = "second"
)

// Defines values for UpdateMethodRateLimitJSONBodyStatus.
const (
	UpdateMethodRateLimitJSONBodyStatusDisabled UpdateMethodRateLimitJSONBodyStatus = "disabled"
	UpdateMethodRateLimitJSONBodyStatusEnabled  UpdateMethodRateLimitJSONBodyStatus = "enabled"
)

// Defines values for FetchEndpointMetricParamsPeriod.
const (
	FetchEndpointMetricParamsPeriodDay   FetchEndpointMetricParamsPeriod = "day"
	FetchEndpointMetricParamsPeriodHour  FetchEndpointMetricParamsPeriod = "hour"
	FetchEndpointMetricParamsPeriodMonth FetchEndpointMetricParamsPeriod = "month"
	FetchEndpointMetricParamsPeriodWeek  FetchEndpointMetricParamsPeriod = "week"
)

// Defines values for FetchEndpointMetricParamsMetric.
const (
	MethodCallBreakdown     FetchEndpointMetricParamsMetric = "method_call_breakdown"
	MethodCallsOverTime     FetchEndpointMetricParamsMetric = "method_calls_over_time"
	MethodResponseTimeMax   FetchEndpointMetricParamsMetric = "method_response_time_max"
	ResponseStatusBreakdown FetchEndpointMetricParamsMetric = "response_status_breakdown"
	ResponseStatusOverTime  FetchEndpointMetricParamsMetric = "response_status_over_time"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsCors.
const (
	UpdateSecurityOptionsJSONBodyOptionsCorsDisabled UpdateSecurityOptionsJSONBodyOptionsCors = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsCorsEnabled  UpdateSecurityOptionsJSONBodyOptionsCors = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsDomainMasks.
const (
	UpdateSecurityOptionsJSONBodyOptionsDomainMasksDisabled UpdateSecurityOptionsJSONBodyOptionsDomainMasks = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsDomainMasksEnabled  UpdateSecurityOptionsJSONBodyOptionsDomainMasks = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsHsts.
const (
	UpdateSecurityOptionsJSONBodyOptionsHstsDisabled UpdateSecurityOptionsJSONBodyOptionsHsts = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsHstsEnabled  UpdateSecurityOptionsJSONBodyOptionsHsts = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsIps.
const (
	UpdateSecurityOptionsJSONBodyOptionsIpsDisabled UpdateSecurityOptionsJSONBodyOptionsIps = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsIpsEnabled  UpdateSecurityOptionsJSONBodyOptionsIps = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsJwts.
const (
	UpdateSecurityOptionsJSONBodyOptionsJwtsDisabled UpdateSecurityOptionsJSONBodyOptionsJwts = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsJwtsEnabled  UpdateSecurityOptionsJSONBodyOptionsJwts = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsReferrers.
const (
	UpdateSecurityOptionsJSONBodyOptionsReferrersDisabled UpdateSecurityOptionsJSONBodyOptionsReferrers = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsReferrersEnabled  UpdateSecurityOptionsJSONBodyOptionsReferrers = "enabled"
)

// Defines values for UpdateSecurityOptionsJSONBodyOptionsTokens.
const (
	UpdateSecurityOptionsJSONBodyOptionsTokensDisabled UpdateSecurityOptionsJSONBodyOptionsTokens = "disabled"
	UpdateSecurityOptionsJSONBodyOptionsTokensEnabled  UpdateSecurityOptionsJSONBodyOptionsTokens = "enabled"
)

// Chain defines model for chain.
type Chain struct {
	IsSelectChain *bool      `json:"is_select_chain,omitempty"`
	Networks      *[]Network `json:"networks,omitempty"`
	Slug          *string    `json:"slug,omitempty"`
}

// ChainUsage defines model for chain_usage.
type ChainUsage struct {
	CreditsUsed *int    `json:"credits_used,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// Endpoint defines model for endpoint.
type Endpoint struct {
	// Chain chain slug
	Chain   string  `json:"chain"`
	HttpUrl string  `json:"http_url"`
	Id      string  `json:"id"`
	Label   *string `json:"label"`

	// Network network slug
	Network string  `json:"network"`
	WssUrl  *string `json:"wss_url"`
}

// EndpointDomainMask defines model for endpoint_domain_mask.
type EndpointDomainMask struct {
	Domain *string `json:"domain,omitempty"`
	Id     *string `json:"id,omitempty"`
}

// EndpointIp defines model for endpoint_ip.
type EndpointIp struct {
	Id *string `json:"id,omitempty"`
	Ip *string `json:"ip,omitempty"`
}

// EndpointJwt defines model for endpoint_jwt.
type EndpointJwt struct {
	Id        *string `json:"id,omitempty"`
	Kid       *string `json:"kid,omitempty"`
	Name      *string `json:"name,omitempty"`
	PublicKey *string `json:"public_key,omitempty"`
}

// EndpointMetric defines model for endpoint_metric.
type EndpointMetric struct {
	Data *[][]int `json:"data,omitempty"`
	Tag  *string  `json:"tag,omitempty"`
}

// EndpointRateLimits defines model for endpoint_rate_limits.
type EndpointRateLimits struct {
	Account       *int  `json:"account"`
	RateLimitByIp *bool `json:"rate_limit_by_ip"`
	Rpd           *int  `json:"rpd"`
	Rpm           *int  `json:"rpm"`
	Rps           *int  `json:"rps"`
}

// EndpointReferrer defines model for endpoint_referrer.
type EndpointReferrer struct {
	Id       *string `json:"id,omitempty"`
	Referrer *string `json:"referrer,omitempty"`
}

// EndpointSecurity defines model for endpoint_security.
type EndpointSecurity struct {
	DomainMasks *[]EndpointDomainMask `json:"domain_masks,omitempty"`
	Ips         *[]EndpointIp         `json:"ips,omitempty"`
	Jwts        *[]EndpointJwt        `json:"jwts,omitempty"`
	Options     *struct {
		DomainMasks *bool `json:"domainMasks"`
		Ips         *bool `json:"ips"`
		Jwts        *bool `json:"jwts"`
		Referrers   *bool `json:"referrers"`
		Tokens      *bool `json:"tokens"`
	} `json:"options,omitempty"`
	Referrers *[]EndpointReferrer `json:"referrers,omitempty"`
	Tokens    *[]EndpointToken    `json:"tokens,omitempty"`
}

// EndpointToken defines model for endpoint_token.
type EndpointToken struct {
	Id    *string `json:"id,omitempty"`
	Token *string `json:"token,omitempty"`
}

// EndpointUsage defines model for endpoint_usage.
type EndpointUsage struct {
	Chain            *string        `json:"chain,omitempty"`
	CreditsUsed      *int           `json:"credits_used,omitempty"`
	Label            *string        `json:"label"`
	MethodsBreakdown *[]MethodUsage `json:"methods_breakdown,omitempty"`
	Name             *string        `json:"name,omitempty"`
	Network          *string        `json:"network,omitempty"`
}

// Invoice defines model for invoice.
type Invoice struct {
	AmountDue     *int    `json:"amount_due,omitempty"`
	AmountPaid    *int    `json:"amount_paid,omitempty"`
	BillingReason *string `json:"billing_reason,omitempty"`
	Created       *int    `json:"created,omitempty"`
	Id            *string `json:"id,omitempty"`
	Lines         *[]struct {
		Amount      *int    `json:"amount,omitempty"`
		Description *string `json:"description,omitempty"`
	} `json:"lines,omitempty"`
	PeriodEnd   *int    `json:"period_end,omitempty"`
	PeriodStart *int    `json:"period_start,omitempty"`
	Status      *string `json:"status,omitempty"`
	Subtotal    *int    `json:"subtotal,omitempty"`
}

// MethodUsage defines model for method_usage.
type MethodUsage struct {
	Archive     *bool   `json:"archive"`
	CreditsUsed *int    `json:"credits_used,omitempty"`
	MethodName  *string `json:"method_name,omitempty"`
}

// Network defines model for network.
type Network struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// Payment defines model for payment.
type Payment struct {
	Amount            *string `json:"amount,omitempty"`
	CardLast4         *string `json:"card_last_4"`
	CreatedAt         *string `json:"created_at,omitempty"`
	Currency          *string `json:"currency,omitempty"`
	MarketplaceAmount *int    `json:"marketplace_amount"`
	Status            *string `json:"status,omitempty"`
}

// SingleEndpoint defines model for single_endpoint.
type SingleEndpoint struct {
	// Chain chain slug
	Chain   string  `json:"chain"`
	HttpUrl string  `json:"http_url"`
	Id      string  `json:"id"`
	Label   *string `json:"label"`

	// Network network slug
	Network    string              `json:"network"`
	RateLimits *EndpointRateLimits `json:"rate_limits,omitempty"`
	Security   EndpointSecurity    `json:"security"`
	WssUrl     *string             `json:"wss_url"`
}

// ListEndpointsParams defines parameters for ListEndpoints.
type ListEndpointsParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateEndpointJSONBody defines parameters for CreateEndpoint.
type CreateEndpointJSONBody struct {
	Chain   *string `json:"chain,omitempty"`
	Network *string `json:"network,omitempty"`
}

// UpdateEndpointJSONBody defines parameters for UpdateEndpoint.
type UpdateEndpointJSONBody struct {
	Label *string `json:"label,omitempty"`
}

// CreateMethodRateLimitJSONBody defines parameters for CreateMethodRateLimit.
type CreateMethodRateLimitJSONBody struct {
	Interval CreateMethodRateLimitJSONBodyInterval `json:"interval"`
	Methods  []string                              `json:"methods"`
	Rate     int                                   `json:"rate"`
}

// CreateMethodRateLimitJSONBodyInterval defines parameters for CreateMethodRateLimit.
type CreateMethodRateLimitJSONBodyInterval string

// UpdateMethodRateLimitJSONBody defines parameters for UpdateMethodRateLimit.
type UpdateMethodRateLimitJSONBody struct {
	Methods *[]string                            `json:"methods,omitempty"`
	Rate    *int                                 `json:"rate,omitempty"`
	Status  *UpdateMethodRateLimitJSONBodyStatus `json:"status,omitempty"`
}

// UpdateMethodRateLimitJSONBodyStatus defines parameters for UpdateMethodRateLimit.
type UpdateMethodRateLimitJSONBodyStatus string

// FetchEndpointMetricParams defines parameters for FetchEndpointMetric.
type FetchEndpointMetricParams struct {
	// Period hour, day, week, month
	Period FetchEndpointMetricParamsPeriod `form:"period" json:"period"`

	// Metric method_calls_over_time, response_status_over_time, method_call_breakdown, response_status_breakdown, method_response_time_max
	Metric FetchEndpointMetricParamsMetric `form:"metric" json:"metric"`
}

// FetchEndpointMetricParamsPeriod defines parameters for FetchEndpointMetric.
type FetchEndpointMetricParamsPeriod string

// FetchEndpointMetricParamsMetric defines parameters for FetchEndpointMetric.
type FetchEndpointMetricParamsMetric string

// UpdateRateLimitsJSONBody defines parameters for UpdateRateLimits.
type UpdateRateLimitsJSONBody struct {
	RateLimits struct {
		Rpd *int `json:"rpd,omitempty"`
		Rpm *int `json:"rpm,omitempty"`
		Rps *int `json:"rps,omitempty"`
	} `json:"rate_limits"`
}

// CreateDomainMaskJSONBody defines parameters for CreateDomainMask.
type CreateDomainMaskJSONBody struct {
	DomainMask *string `json:"domain_mask,omitempty"`
}

// CreateIpJSONBody defines parameters for CreateIp.
type CreateIpJSONBody struct {
	Ip *string `json:"ip,omitempty"`
}

// CreateJwtJSONBody defines parameters for CreateJwt.
type CreateJwtJSONBody struct {
	Kid       *string `json:"kid,omitempty"`
	Name      *string `json:"name,omitempty"`
	PublicKey *string `json:"public_key,omitempty"`
}

// CreateReferrerJSONBody defines parameters for CreateReferrer.
type CreateReferrerJSONBody struct {
	Referrer *string `json:"referrer,omitempty"`
}

// UpdateSecurityOptionsJSONBody defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBody struct {
	Options struct {
		Cors        *UpdateSecurityOptionsJSONBodyOptionsCors        `json:"cors,omitempty"`
		DomainMasks *UpdateSecurityOptionsJSONBodyOptionsDomainMasks `json:"domainMasks,omitempty"`
		Hsts        *UpdateSecurityOptionsJSONBodyOptionsHsts        `json:"hsts,omitempty"`
		Ips         *UpdateSecurityOptionsJSONBodyOptionsIps         `json:"ips,omitempty"`
		Jwts        *UpdateSecurityOptionsJSONBodyOptionsJwts        `json:"jwts,omitempty"`
		Referrers   *UpdateSecurityOptionsJSONBodyOptionsReferrers   `json:"referrers,omitempty"`
		Tokens      *UpdateSecurityOptionsJSONBodyOptionsTokens      `json:"tokens,omitempty"`
	} `json:"options"`
}

// UpdateSecurityOptionsJSONBodyOptionsCors defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsCors string

// UpdateSecurityOptionsJSONBodyOptionsDomainMasks defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsDomainMasks string

// UpdateSecurityOptionsJSONBodyOptionsHsts defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsHsts string

// UpdateSecurityOptionsJSONBodyOptionsIps defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsIps string

// UpdateSecurityOptionsJSONBodyOptionsJwts defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsJwts string

// UpdateSecurityOptionsJSONBodyOptionsReferrers defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsReferrers string

// UpdateSecurityOptionsJSONBodyOptionsTokens defines parameters for UpdateSecurityOptions.
type UpdateSecurityOptionsJSONBodyOptionsTokens string

// UsageParams defines parameters for Usage.
type UsageParams struct {
	// StartTime Start time
	StartTime *int `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End time
	EndTime *int `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// UsageByChainParams defines parameters for UsageByChain.
type UsageByChainParams struct {
	// StartTime Start time
	StartTime *int `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End time
	EndTime *int `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// UsageByEndpointParams defines parameters for UsageByEndpoint.
type UsageByEndpointParams struct {
	// StartTime Start time
	StartTime *int `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End time
	EndTime *int `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// UsageByMethodParams defines parameters for UsageByMethod.
type UsageByMethodParams struct {
	// StartTime Start time
	StartTime *int `form:"start_time,omitempty" json:"start_time,omitempty"`

	// EndTime End time
	EndTime *int `form:"end_time,omitempty" json:"end_time,omitempty"`
}

// CreateEndpointJSONRequestBody defines body for CreateEndpoint for application/json ContentType.
type CreateEndpointJSONRequestBody CreateEndpointJSONBody

// UpdateEndpointJSONRequestBody defines body for UpdateEndpoint for application/json ContentType.
type UpdateEndpointJSONRequestBody UpdateEndpointJSONBody

// CreateMethodRateLimitJSONRequestBody defines body for CreateMethodRateLimit for application/json ContentType.
type CreateMethodRateLimitJSONRequestBody CreateMethodRateLimitJSONBody

// UpdateMethodRateLimitJSONRequestBody defines body for UpdateMethodRateLimit for application/json ContentType.
type UpdateMethodRateLimitJSONRequestBody UpdateMethodRateLimitJSONBody

// UpdateRateLimitsJSONRequestBody defines body for UpdateRateLimits for application/json ContentType.
type UpdateRateLimitsJSONRequestBody UpdateRateLimitsJSONBody

// CreateDomainMaskJSONRequestBody defines body for CreateDomainMask for application/json ContentType.
type CreateDomainMaskJSONRequestBody CreateDomainMaskJSONBody

// CreateIpJSONRequestBody defines body for CreateIp for application/json ContentType.
type CreateIpJSONRequestBody CreateIpJSONBody

// CreateJwtJSONRequestBody defines body for CreateJwt for application/json ContentType.
type CreateJwtJSONRequestBody CreateJwtJSONBody

// CreateReferrerJSONRequestBody defines body for CreateReferrer for application/json ContentType.
type CreateReferrerJSONRequestBody CreateReferrerJSONBody

// UpdateSecurityOptionsJSONRequestBody defines body for UpdateSecurityOptions for application/json ContentType.
type UpdateSecurityOptionsJSONRequestBody UpdateSecurityOptionsJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Invoices request
	Invoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Payments request
	Payments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Chains request
	Chains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEndpoints request
	ListEndpoints(ctx context.Context, params *ListEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEndpointWithBody request with any body
	CreateEndpointWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEndpoint(ctx context.Context, body CreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveEndpoint request
	ArchiveEndpoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowEndpoint request
	ShowEndpoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEndpointWithBody request with any body
	UpdateEndpointWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEndpoint(ctx context.Context, id string, body UpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMethodRateLimits request
	GetMethodRateLimits(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMethodRateLimitWithBody request with any body
	CreateMethodRateLimitWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMethodRateLimit(ctx context.Context, id string, body CreateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMethodRateLimit request
	DeleteMethodRateLimit(ctx context.Context, id string, methodRateLimitId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMethodRateLimitWithBody request with any body
	UpdateMethodRateLimitWithBody(ctx context.Context, id string, methodRateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMethodRateLimit(ctx context.Context, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchEndpointMetric request
	FetchEndpointMetric(ctx context.Context, id string, params *FetchEndpointMetricParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRateLimitsWithBody request with any body
	UpdateRateLimitsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRateLimits(ctx context.Context, id string, body UpdateRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDomainMaskWithBody request with any body
	CreateDomainMaskWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDomainMask(ctx context.Context, id string, body CreateDomainMaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDomainMask request
	DeleteDomainMask(ctx context.Context, id string, domainMaskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIpWithBody request with any body
	CreateIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIp(ctx context.Context, id string, body CreateIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIp request
	DeleteIp(ctx context.Context, id string, ipId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJwtWithBody request with any body
	CreateJwtWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJwt(ctx context.Context, id string, body CreateJwtJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJwt request
	DeleteJwt(ctx context.Context, id string, jwtId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateReferrerWithBody request with any body
	CreateReferrerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateReferrer(ctx context.Context, id string, body CreateReferrerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReferrer request
	DeleteReferrer(ctx context.Context, id string, referrerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAuthenticationToken request
	CreateAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, id string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecurityOptions request
	GetSecurityOptions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSecurityOptionsWithBody request with any body
	UpdateSecurityOptionsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSecurityOptions(ctx context.Context, id string, body UpdateSecurityOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Usage request
	Usage(ctx context.Context, params *UsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsageByChain request
	UsageByChain(ctx context.Context, params *UsageByChainParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsageByEndpoint request
	UsageByEndpoint(ctx context.Context, params *UsageByEndpointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsageByMethod request
	UsageByMethod(ctx context.Context, params *UsageByMethodParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Invoices(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInvoicesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Payments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPaymentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Chains(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChainsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEndpoints(ctx context.Context, params *ListEndpointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEndpointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEndpointWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEndpointRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEndpoint(ctx context.Context, body CreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEndpointRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveEndpoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveEndpointRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowEndpoint(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowEndpointRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEndpointWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEndpointRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEndpoint(ctx context.Context, id string, body UpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEndpointRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMethodRateLimits(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMethodRateLimitsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMethodRateLimitWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMethodRateLimitRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMethodRateLimit(ctx context.Context, id string, body CreateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMethodRateLimitRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMethodRateLimit(ctx context.Context, id string, methodRateLimitId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMethodRateLimitRequest(c.Server, id, methodRateLimitId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMethodRateLimitWithBody(ctx context.Context, id string, methodRateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMethodRateLimitRequestWithBody(c.Server, id, methodRateLimitId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMethodRateLimit(ctx context.Context, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMethodRateLimitRequest(c.Server, id, methodRateLimitId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchEndpointMetric(ctx context.Context, id string, params *FetchEndpointMetricParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchEndpointMetricRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRateLimitsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRateLimitsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRateLimits(ctx context.Context, id string, body UpdateRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRateLimitsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomainMaskWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainMaskRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomainMask(ctx context.Context, id string, body CreateDomainMaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainMaskRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDomainMask(ctx context.Context, id string, domainMaskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDomainMaskRequest(c.Server, id, domainMaskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIpWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIp(ctx context.Context, id string, body CreateIpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIp(ctx context.Context, id string, ipId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIpRequest(c.Server, id, ipId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJwtWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJwtRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJwt(ctx context.Context, id string, body CreateJwtJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJwtRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJwt(ctx context.Context, id string, jwtId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJwtRequest(c.Server, id, jwtId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReferrerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReferrerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateReferrer(ctx context.Context, id string, body CreateReferrerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateReferrerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReferrer(ctx context.Context, id string, referrerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReferrerRequest(c.Server, id, referrerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAuthenticationToken(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthenticationTokenRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, id string, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, id, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecurityOptions(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecurityOptionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSecurityOptionsWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSecurityOptionsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSecurityOptions(ctx context.Context, id string, body UpdateSecurityOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSecurityOptionsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Usage(ctx context.Context, params *UsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsageByChain(ctx context.Context, params *UsageByChainParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageByChainRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsageByEndpoint(ctx context.Context, params *UsageByEndpointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageByEndpointRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsageByMethod(ctx context.Context, params *UsageByMethodParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsageByMethodRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewInvoicesRequest generates requests for Invoices
func NewInvoicesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/billing/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPaymentsRequest generates requests for Payments
func NewPaymentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/billing/payments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChainsRequest generates requests for Chains
func NewChainsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/chains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEndpointsRequest generates requests for ListEndpoints
func NewListEndpointsRequest(server string, params *ListEndpointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEndpointRequest calls the generic CreateEndpoint builder with application/json body
func NewCreateEndpointRequest(server string, body CreateEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEndpointRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEndpointRequestWithBody generates requests for CreateEndpoint with any type of body
func NewCreateEndpointRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveEndpointRequest generates requests for ArchiveEndpoint
func NewArchiveEndpointRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowEndpointRequest generates requests for ShowEndpoint
func NewShowEndpointRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEndpointRequest calls the generic UpdateEndpoint builder with application/json body
func NewUpdateEndpointRequest(server string, id string, body UpdateEndpointJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEndpointRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateEndpointRequestWithBody generates requests for UpdateEndpoint with any type of body
func NewUpdateEndpointRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMethodRateLimitsRequest generates requests for GetMethodRateLimits
func NewGetMethodRateLimitsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/method-rate-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMethodRateLimitRequest calls the generic CreateMethodRateLimit builder with application/json body
func NewCreateMethodRateLimitRequest(server string, id string, body CreateMethodRateLimitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMethodRateLimitRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateMethodRateLimitRequestWithBody generates requests for CreateMethodRateLimit with any type of body
func NewCreateMethodRateLimitRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/method-rate-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMethodRateLimitRequest generates requests for DeleteMethodRateLimit
func NewDeleteMethodRateLimitRequest(server string, id string, methodRateLimitId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "method_rate_limit_id", runtime.ParamLocationPath, methodRateLimitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/method-rate-limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMethodRateLimitRequest calls the generic UpdateMethodRateLimit builder with application/json body
func NewUpdateMethodRateLimitRequest(server string, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMethodRateLimitRequestWithBody(server, id, methodRateLimitId, "application/json", bodyReader)
}

// NewUpdateMethodRateLimitRequestWithBody generates requests for UpdateMethodRateLimit with any type of body
func NewUpdateMethodRateLimitRequestWithBody(server string, id string, methodRateLimitId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "method_rate_limit_id", runtime.ParamLocationPath, methodRateLimitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/method-rate-limits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFetchEndpointMetricRequest generates requests for FetchEndpointMetric
func NewFetchEndpointMetricRequest(server string, id string, params *FetchEndpointMetricParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period", runtime.ParamLocationQuery, params.Period); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metric", runtime.ParamLocationQuery, params.Metric); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRateLimitsRequest calls the generic UpdateRateLimits builder with application/json body
func NewUpdateRateLimitsRequest(server string, id string, body UpdateRateLimitsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRateLimitsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateRateLimitsRequestWithBody generates requests for UpdateRateLimits with any type of body
func NewUpdateRateLimitsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/rate-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDomainMaskRequest calls the generic CreateDomainMask builder with application/json body
func NewCreateDomainMaskRequest(server string, id string, body CreateDomainMaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDomainMaskRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateDomainMaskRequestWithBody generates requests for CreateDomainMask with any type of body
func NewCreateDomainMaskRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/domain_masks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDomainMaskRequest generates requests for DeleteDomainMask
func NewDeleteDomainMaskRequest(server string, id string, domainMaskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domain_mask_id", runtime.ParamLocationPath, domainMaskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/domain_masks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIpRequest calls the generic CreateIp builder with application/json body
func NewCreateIpRequest(server string, id string, body CreateIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIpRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateIpRequestWithBody generates requests for CreateIp with any type of body
func NewCreateIpRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/ips", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIpRequest generates requests for DeleteIp
func NewDeleteIpRequest(server string, id string, ipId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ip_id", runtime.ParamLocationPath, ipId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/ips/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJwtRequest calls the generic CreateJwt builder with application/json body
func NewCreateJwtRequest(server string, id string, body CreateJwtJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJwtRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateJwtRequestWithBody generates requests for CreateJwt with any type of body
func NewCreateJwtRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/jwts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJwtRequest generates requests for DeleteJwt
func NewDeleteJwtRequest(server string, id string, jwtId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "jwt_id", runtime.ParamLocationPath, jwtId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/jwts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateReferrerRequest calls the generic CreateReferrer builder with application/json body
func NewCreateReferrerRequest(server string, id string, body CreateReferrerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateReferrerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateReferrerRequestWithBody generates requests for CreateReferrer with any type of body
func NewCreateReferrerRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/referrers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReferrerRequest generates requests for DeleteReferrer
func NewDeleteReferrerRequest(server string, id string, referrerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "referrer_id", runtime.ParamLocationPath, referrerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/referrers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAuthenticationTokenRequest generates requests for CreateAuthenticationToken
func NewCreateAuthenticationTokenRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, id string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security/tokens/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecurityOptionsRequest generates requests for GetSecurityOptions
func NewGetSecurityOptionsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security_options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSecurityOptionsRequest calls the generic UpdateSecurityOptions builder with application/json body
func NewUpdateSecurityOptionsRequest(server string, id string, body UpdateSecurityOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSecurityOptionsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateSecurityOptionsRequestWithBody generates requests for UpdateSecurityOptions with any type of body
func NewUpdateSecurityOptionsRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/endpoints/%s/security_options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsageRequest generates requests for Usage
func NewUsageRequest(server string, params *UsageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/usage/rpc")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageByChainRequest generates requests for UsageByChain
func NewUsageByChainRequest(server string, params *UsageByChainParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/usage/rpc/by-chain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageByEndpointRequest generates requests for UsageByEndpoint
func NewUsageByEndpointRequest(server string, params *UsageByEndpointParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/usage/rpc/by-endpoint")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsageByMethodRequest generates requests for UsageByMethod
func NewUsageByMethodRequest(server string, params *UsageByMethodParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v0/usage/rpc/by-method")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// InvoicesWithResponse request
	InvoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InvoicesResponse, error)

	// PaymentsWithResponse request
	PaymentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PaymentsResponse, error)

	// ChainsWithResponse request
	ChainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ChainsResponse, error)

	// ListEndpointsWithResponse request
	ListEndpointsWithResponse(ctx context.Context, params *ListEndpointsParams, reqEditors ...RequestEditorFn) (*ListEndpointsResponse, error)

	// CreateEndpointWithBodyWithResponse request with any body
	CreateEndpointWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEndpointResponse, error)

	CreateEndpointWithResponse(ctx context.Context, body CreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEndpointResponse, error)

	// ArchiveEndpointWithResponse request
	ArchiveEndpointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ArchiveEndpointResponse, error)

	// ShowEndpointWithResponse request
	ShowEndpointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ShowEndpointResponse, error)

	// UpdateEndpointWithBodyWithResponse request with any body
	UpdateEndpointWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEndpointResponse, error)

	UpdateEndpointWithResponse(ctx context.Context, id string, body UpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEndpointResponse, error)

	// GetMethodRateLimitsWithResponse request
	GetMethodRateLimitsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMethodRateLimitsResponse, error)

	// CreateMethodRateLimitWithBodyWithResponse request with any body
	CreateMethodRateLimitWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMethodRateLimitResponse, error)

	CreateMethodRateLimitWithResponse(ctx context.Context, id string, body CreateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMethodRateLimitResponse, error)

	// DeleteMethodRateLimitWithResponse request
	DeleteMethodRateLimitWithResponse(ctx context.Context, id string, methodRateLimitId string, reqEditors ...RequestEditorFn) (*DeleteMethodRateLimitResponse, error)

	// UpdateMethodRateLimitWithBodyWithResponse request with any body
	UpdateMethodRateLimitWithBodyWithResponse(ctx context.Context, id string, methodRateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMethodRateLimitResponse, error)

	UpdateMethodRateLimitWithResponse(ctx context.Context, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMethodRateLimitResponse, error)

	// FetchEndpointMetricWithResponse request
	FetchEndpointMetricWithResponse(ctx context.Context, id string, params *FetchEndpointMetricParams, reqEditors ...RequestEditorFn) (*FetchEndpointMetricResponse, error)

	// UpdateRateLimitsWithBodyWithResponse request with any body
	UpdateRateLimitsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRateLimitsResponse, error)

	UpdateRateLimitsWithResponse(ctx context.Context, id string, body UpdateRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRateLimitsResponse, error)

	// CreateDomainMaskWithBodyWithResponse request with any body
	CreateDomainMaskWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainMaskResponse, error)

	CreateDomainMaskWithResponse(ctx context.Context, id string, body CreateDomainMaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainMaskResponse, error)

	// DeleteDomainMaskWithResponse request
	DeleteDomainMaskWithResponse(ctx context.Context, id string, domainMaskId string, reqEditors ...RequestEditorFn) (*DeleteDomainMaskResponse, error)

	// CreateIpWithBodyWithResponse request with any body
	CreateIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpResponse, error)

	CreateIpWithResponse(ctx context.Context, id string, body CreateIpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpResponse, error)

	// DeleteIpWithResponse request
	DeleteIpWithResponse(ctx context.Context, id string, ipId string, reqEditors ...RequestEditorFn) (*DeleteIpResponse, error)

	// CreateJwtWithBodyWithResponse request with any body
	CreateJwtWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJwtResponse, error)

	CreateJwtWithResponse(ctx context.Context, id string, body CreateJwtJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJwtResponse, error)

	// DeleteJwtWithResponse request
	DeleteJwtWithResponse(ctx context.Context, id string, jwtId string, reqEditors ...RequestEditorFn) (*DeleteJwtResponse, error)

	// CreateReferrerWithBodyWithResponse request with any body
	CreateReferrerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReferrerResponse, error)

	CreateReferrerWithResponse(ctx context.Context, id string, body CreateReferrerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReferrerResponse, error)

	// DeleteReferrerWithResponse request
	DeleteReferrerWithResponse(ctx context.Context, id string, referrerId string, reqEditors ...RequestEditorFn) (*DeleteReferrerResponse, error)

	// CreateAuthenticationTokenWithResponse request
	CreateAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CreateAuthenticationTokenResponse, error)

	// DeleteTokenWithResponse request
	DeleteTokenWithResponse(ctx context.Context, id string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// GetSecurityOptionsWithResponse request
	GetSecurityOptionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSecurityOptionsResponse, error)

	// UpdateSecurityOptionsWithBodyWithResponse request with any body
	UpdateSecurityOptionsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSecurityOptionsResponse, error)

	UpdateSecurityOptionsWithResponse(ctx context.Context, id string, body UpdateSecurityOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSecurityOptionsResponse, error)

	// UsageWithResponse request
	UsageWithResponse(ctx context.Context, params *UsageParams, reqEditors ...RequestEditorFn) (*UsageResponse, error)

	// UsageByChainWithResponse request
	UsageByChainWithResponse(ctx context.Context, params *UsageByChainParams, reqEditors ...RequestEditorFn) (*UsageByChainResponse, error)

	// UsageByEndpointWithResponse request
	UsageByEndpointWithResponse(ctx context.Context, params *UsageByEndpointParams, reqEditors ...RequestEditorFn) (*UsageByEndpointResponse, error)

	// UsageByMethodWithResponse request
	UsageByMethodWithResponse(ctx context.Context, params *UsageByMethodParams, reqEditors ...RequestEditorFn) (*UsageByMethodResponse, error)
}

type InvoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Invoices *[]Invoice `json:"invoices,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r InvoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InvoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PaymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Payments *[]Payment `json:"payments,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r PaymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PaymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  []Chain `json:"data"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r ChainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *[]Endpoint `json:"data"`
		Error *string     `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  SingleEndpoint `json:"data"`
		Error *string        `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ArchiveEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *SingleEndpoint `json:"data,omitempty"`
		Error *string         `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r ShowEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMethodRateLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetMethodRateLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMethodRateLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMethodRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateMethodRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMethodRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMethodRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMethodRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMethodRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMethodRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateMethodRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMethodRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchEndpointMetricResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  []EndpointMetric `json:"data"`
		Error *string          `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r FetchEndpointMetricResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEndpointMetricResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRateLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateRateLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRateLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDomainMaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateDomainMaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDomainMaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDomainMaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDomainMaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDomainMaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *bool   `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteIpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJwtResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateJwtResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJwtResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJwtResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteJwtResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJwtResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateReferrerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateReferrerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReferrerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReferrerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *bool   `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteReferrerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReferrerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAuthenticationTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAuthenticationTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthenticationTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data  *bool   `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecurityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSecurityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecurityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSecurityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateSecurityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSecurityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			CreditsRemaining *int `json:"credits_remaining"`
			CreditsUsed      int  `json:"credits_used"`
			EndTime          int  `json:"end_time"`
			Limit            *int `json:"limit"`
			Overages         *int `json:"overages"`
			StartTime        int  `json:"start_time"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r UsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageByChainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Chains    *[]ChainUsage `json:"chains,omitempty"`
			EndTime   *int          `json:"end_time,omitempty"`
			StartTime *int          `json:"start_time,omitempty"`
		} `json:"data"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r UsageByChainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageByChainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageByEndpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			EndTime   *int             `json:"end_time,omitempty"`
			Endpoints *[]EndpointUsage `json:"endpoints,omitempty"`
			StartTime *int             `json:"start_time,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r UsageByEndpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageByEndpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsageByMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			EndTime   *int           `json:"end_time,omitempty"`
			Methods   *[]MethodUsage `json:"methods,omitempty"`
			StartTime *int           `json:"start_time,omitempty"`
		} `json:"data,omitempty"`
		Error *string `json:"error"`
	}
}

// Status returns HTTPResponse.Status
func (r UsageByMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsageByMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// InvoicesWithResponse request returning *InvoicesResponse
func (c *ClientWithResponses) InvoicesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InvoicesResponse, error) {
	rsp, err := c.Invoices(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInvoicesResponse(rsp)
}

// PaymentsWithResponse request returning *PaymentsResponse
func (c *ClientWithResponses) PaymentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PaymentsResponse, error) {
	rsp, err := c.Payments(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePaymentsResponse(rsp)
}

// ChainsWithResponse request returning *ChainsResponse
func (c *ClientWithResponses) ChainsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ChainsResponse, error) {
	rsp, err := c.Chains(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChainsResponse(rsp)
}

// ListEndpointsWithResponse request returning *ListEndpointsResponse
func (c *ClientWithResponses) ListEndpointsWithResponse(ctx context.Context, params *ListEndpointsParams, reqEditors ...RequestEditorFn) (*ListEndpointsResponse, error) {
	rsp, err := c.ListEndpoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEndpointsResponse(rsp)
}

// CreateEndpointWithBodyWithResponse request with arbitrary body returning *CreateEndpointResponse
func (c *ClientWithResponses) CreateEndpointWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEndpointResponse, error) {
	rsp, err := c.CreateEndpointWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEndpointResponse(rsp)
}

func (c *ClientWithResponses) CreateEndpointWithResponse(ctx context.Context, body CreateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEndpointResponse, error) {
	rsp, err := c.CreateEndpoint(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEndpointResponse(rsp)
}

// ArchiveEndpointWithResponse request returning *ArchiveEndpointResponse
func (c *ClientWithResponses) ArchiveEndpointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ArchiveEndpointResponse, error) {
	rsp, err := c.ArchiveEndpoint(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveEndpointResponse(rsp)
}

// ShowEndpointWithResponse request returning *ShowEndpointResponse
func (c *ClientWithResponses) ShowEndpointWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ShowEndpointResponse, error) {
	rsp, err := c.ShowEndpoint(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowEndpointResponse(rsp)
}

// UpdateEndpointWithBodyWithResponse request with arbitrary body returning *UpdateEndpointResponse
func (c *ClientWithResponses) UpdateEndpointWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEndpointResponse, error) {
	rsp, err := c.UpdateEndpointWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEndpointResponse(rsp)
}

func (c *ClientWithResponses) UpdateEndpointWithResponse(ctx context.Context, id string, body UpdateEndpointJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEndpointResponse, error) {
	rsp, err := c.UpdateEndpoint(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEndpointResponse(rsp)
}

// GetMethodRateLimitsWithResponse request returning *GetMethodRateLimitsResponse
func (c *ClientWithResponses) GetMethodRateLimitsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMethodRateLimitsResponse, error) {
	rsp, err := c.GetMethodRateLimits(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMethodRateLimitsResponse(rsp)
}

// CreateMethodRateLimitWithBodyWithResponse request with arbitrary body returning *CreateMethodRateLimitResponse
func (c *ClientWithResponses) CreateMethodRateLimitWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMethodRateLimitResponse, error) {
	rsp, err := c.CreateMethodRateLimitWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMethodRateLimitResponse(rsp)
}

func (c *ClientWithResponses) CreateMethodRateLimitWithResponse(ctx context.Context, id string, body CreateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMethodRateLimitResponse, error) {
	rsp, err := c.CreateMethodRateLimit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMethodRateLimitResponse(rsp)
}

// DeleteMethodRateLimitWithResponse request returning *DeleteMethodRateLimitResponse
func (c *ClientWithResponses) DeleteMethodRateLimitWithResponse(ctx context.Context, id string, methodRateLimitId string, reqEditors ...RequestEditorFn) (*DeleteMethodRateLimitResponse, error) {
	rsp, err := c.DeleteMethodRateLimit(ctx, id, methodRateLimitId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMethodRateLimitResponse(rsp)
}

// UpdateMethodRateLimitWithBodyWithResponse request with arbitrary body returning *UpdateMethodRateLimitResponse
func (c *ClientWithResponses) UpdateMethodRateLimitWithBodyWithResponse(ctx context.Context, id string, methodRateLimitId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMethodRateLimitResponse, error) {
	rsp, err := c.UpdateMethodRateLimitWithBody(ctx, id, methodRateLimitId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMethodRateLimitResponse(rsp)
}

func (c *ClientWithResponses) UpdateMethodRateLimitWithResponse(ctx context.Context, id string, methodRateLimitId string, body UpdateMethodRateLimitJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMethodRateLimitResponse, error) {
	rsp, err := c.UpdateMethodRateLimit(ctx, id, methodRateLimitId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMethodRateLimitResponse(rsp)
}

// FetchEndpointMetricWithResponse request returning *FetchEndpointMetricResponse
func (c *ClientWithResponses) FetchEndpointMetricWithResponse(ctx context.Context, id string, params *FetchEndpointMetricParams, reqEditors ...RequestEditorFn) (*FetchEndpointMetricResponse, error) {
	rsp, err := c.FetchEndpointMetric(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchEndpointMetricResponse(rsp)
}

// UpdateRateLimitsWithBodyWithResponse request with arbitrary body returning *UpdateRateLimitsResponse
func (c *ClientWithResponses) UpdateRateLimitsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRateLimitsResponse, error) {
	rsp, err := c.UpdateRateLimitsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRateLimitsResponse(rsp)
}

func (c *ClientWithResponses) UpdateRateLimitsWithResponse(ctx context.Context, id string, body UpdateRateLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRateLimitsResponse, error) {
	rsp, err := c.UpdateRateLimits(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRateLimitsResponse(rsp)
}

// CreateDomainMaskWithBodyWithResponse request with arbitrary body returning *CreateDomainMaskResponse
func (c *ClientWithResponses) CreateDomainMaskWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainMaskResponse, error) {
	rsp, err := c.CreateDomainMaskWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainMaskResponse(rsp)
}

func (c *ClientWithResponses) CreateDomainMaskWithResponse(ctx context.Context, id string, body CreateDomainMaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainMaskResponse, error) {
	rsp, err := c.CreateDomainMask(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainMaskResponse(rsp)
}

// DeleteDomainMaskWithResponse request returning *DeleteDomainMaskResponse
func (c *ClientWithResponses) DeleteDomainMaskWithResponse(ctx context.Context, id string, domainMaskId string, reqEditors ...RequestEditorFn) (*DeleteDomainMaskResponse, error) {
	rsp, err := c.DeleteDomainMask(ctx, id, domainMaskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDomainMaskResponse(rsp)
}

// CreateIpWithBodyWithResponse request with arbitrary body returning *CreateIpResponse
func (c *ClientWithResponses) CreateIpWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpResponse, error) {
	rsp, err := c.CreateIpWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpResponse(rsp)
}

func (c *ClientWithResponses) CreateIpWithResponse(ctx context.Context, id string, body CreateIpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpResponse, error) {
	rsp, err := c.CreateIp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpResponse(rsp)
}

// DeleteIpWithResponse request returning *DeleteIpResponse
func (c *ClientWithResponses) DeleteIpWithResponse(ctx context.Context, id string, ipId string, reqEditors ...RequestEditorFn) (*DeleteIpResponse, error) {
	rsp, err := c.DeleteIp(ctx, id, ipId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIpResponse(rsp)
}

// CreateJwtWithBodyWithResponse request with arbitrary body returning *CreateJwtResponse
func (c *ClientWithResponses) CreateJwtWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJwtResponse, error) {
	rsp, err := c.CreateJwtWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJwtResponse(rsp)
}

func (c *ClientWithResponses) CreateJwtWithResponse(ctx context.Context, id string, body CreateJwtJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJwtResponse, error) {
	rsp, err := c.CreateJwt(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJwtResponse(rsp)
}

// DeleteJwtWithResponse request returning *DeleteJwtResponse
func (c *ClientWithResponses) DeleteJwtWithResponse(ctx context.Context, id string, jwtId string, reqEditors ...RequestEditorFn) (*DeleteJwtResponse, error) {
	rsp, err := c.DeleteJwt(ctx, id, jwtId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJwtResponse(rsp)
}

// CreateReferrerWithBodyWithResponse request with arbitrary body returning *CreateReferrerResponse
func (c *ClientWithResponses) CreateReferrerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateReferrerResponse, error) {
	rsp, err := c.CreateReferrerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReferrerResponse(rsp)
}

func (c *ClientWithResponses) CreateReferrerWithResponse(ctx context.Context, id string, body CreateReferrerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateReferrerResponse, error) {
	rsp, err := c.CreateReferrer(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateReferrerResponse(rsp)
}

// DeleteReferrerWithResponse request returning *DeleteReferrerResponse
func (c *ClientWithResponses) DeleteReferrerWithResponse(ctx context.Context, id string, referrerId string, reqEditors ...RequestEditorFn) (*DeleteReferrerResponse, error) {
	rsp, err := c.DeleteReferrer(ctx, id, referrerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReferrerResponse(rsp)
}

// CreateAuthenticationTokenWithResponse request returning *CreateAuthenticationTokenResponse
func (c *ClientWithResponses) CreateAuthenticationTokenWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CreateAuthenticationTokenResponse, error) {
	rsp, err := c.CreateAuthenticationToken(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthenticationTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, id string, tokenId string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, id, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// GetSecurityOptionsWithResponse request returning *GetSecurityOptionsResponse
func (c *ClientWithResponses) GetSecurityOptionsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSecurityOptionsResponse, error) {
	rsp, err := c.GetSecurityOptions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecurityOptionsResponse(rsp)
}

// UpdateSecurityOptionsWithBodyWithResponse request with arbitrary body returning *UpdateSecurityOptionsResponse
func (c *ClientWithResponses) UpdateSecurityOptionsWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSecurityOptionsResponse, error) {
	rsp, err := c.UpdateSecurityOptionsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSecurityOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateSecurityOptionsWithResponse(ctx context.Context, id string, body UpdateSecurityOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSecurityOptionsResponse, error) {
	rsp, err := c.UpdateSecurityOptions(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSecurityOptionsResponse(rsp)
}

// UsageWithResponse request returning *UsageResponse
func (c *ClientWithResponses) UsageWithResponse(ctx context.Context, params *UsageParams, reqEditors ...RequestEditorFn) (*UsageResponse, error) {
	rsp, err := c.Usage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageResponse(rsp)
}

// UsageByChainWithResponse request returning *UsageByChainResponse
func (c *ClientWithResponses) UsageByChainWithResponse(ctx context.Context, params *UsageByChainParams, reqEditors ...RequestEditorFn) (*UsageByChainResponse, error) {
	rsp, err := c.UsageByChain(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageByChainResponse(rsp)
}

// UsageByEndpointWithResponse request returning *UsageByEndpointResponse
func (c *ClientWithResponses) UsageByEndpointWithResponse(ctx context.Context, params *UsageByEndpointParams, reqEditors ...RequestEditorFn) (*UsageByEndpointResponse, error) {
	rsp, err := c.UsageByEndpoint(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageByEndpointResponse(rsp)
}

// UsageByMethodWithResponse request returning *UsageByMethodResponse
func (c *ClientWithResponses) UsageByMethodWithResponse(ctx context.Context, params *UsageByMethodParams, reqEditors ...RequestEditorFn) (*UsageByMethodResponse, error) {
	rsp, err := c.UsageByMethod(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsageByMethodResponse(rsp)
}

// ParseInvoicesResponse parses an HTTP response from a InvoicesWithResponse call
func ParseInvoicesResponse(rsp *http.Response) (*InvoicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InvoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Invoices *[]Invoice `json:"invoices,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePaymentsResponse parses an HTTP response from a PaymentsWithResponse call
func ParsePaymentsResponse(rsp *http.Response) (*PaymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PaymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Payments *[]Payment `json:"payments,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChainsResponse parses an HTTP response from a ChainsWithResponse call
func ParseChainsResponse(rsp *http.Response) (*ChainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  []Chain `json:"data"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEndpointsResponse parses an HTTP response from a ListEndpointsWithResponse call
func ParseListEndpointsResponse(rsp *http.Response) (*ListEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *[]Endpoint `json:"data"`
			Error *string     `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEndpointResponse parses an HTTP response from a CreateEndpointWithResponse call
func ParseCreateEndpointResponse(rsp *http.Response) (*CreateEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  SingleEndpoint `json:"data"`
			Error *string        `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveEndpointResponse parses an HTTP response from a ArchiveEndpointWithResponse call
func ParseArchiveEndpointResponse(rsp *http.Response) (*ArchiveEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseShowEndpointResponse parses an HTTP response from a ShowEndpointWithResponse call
func ParseShowEndpointResponse(rsp *http.Response) (*ShowEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *SingleEndpoint `json:"data,omitempty"`
			Error *string         `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateEndpointResponse parses an HTTP response from a UpdateEndpointWithResponse call
func ParseUpdateEndpointResponse(rsp *http.Response) (*UpdateEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMethodRateLimitsResponse parses an HTTP response from a GetMethodRateLimitsWithResponse call
func ParseGetMethodRateLimitsResponse(rsp *http.Response) (*GetMethodRateLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMethodRateLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateMethodRateLimitResponse parses an HTTP response from a CreateMethodRateLimitWithResponse call
func ParseCreateMethodRateLimitResponse(rsp *http.Response) (*CreateMethodRateLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMethodRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteMethodRateLimitResponse parses an HTTP response from a DeleteMethodRateLimitWithResponse call
func ParseDeleteMethodRateLimitResponse(rsp *http.Response) (*DeleteMethodRateLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMethodRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateMethodRateLimitResponse parses an HTTP response from a UpdateMethodRateLimitWithResponse call
func ParseUpdateMethodRateLimitResponse(rsp *http.Response) (*UpdateMethodRateLimitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMethodRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFetchEndpointMetricResponse parses an HTTP response from a FetchEndpointMetricWithResponse call
func ParseFetchEndpointMetricResponse(rsp *http.Response) (*FetchEndpointMetricResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchEndpointMetricResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  []EndpointMetric `json:"data"`
			Error *string          `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRateLimitsResponse parses an HTTP response from a UpdateRateLimitsWithResponse call
func ParseUpdateRateLimitsResponse(rsp *http.Response) (*UpdateRateLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRateLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateDomainMaskResponse parses an HTTP response from a CreateDomainMaskWithResponse call
func ParseCreateDomainMaskResponse(rsp *http.Response) (*CreateDomainMaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDomainMaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDomainMaskResponse parses an HTTP response from a DeleteDomainMaskWithResponse call
func ParseDeleteDomainMaskResponse(rsp *http.Response) (*DeleteDomainMaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDomainMaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateIpResponse parses an HTTP response from a CreateIpWithResponse call
func ParseCreateIpResponse(rsp *http.Response) (*CreateIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteIpResponse parses an HTTP response from a DeleteIpWithResponse call
func ParseDeleteIpResponse(rsp *http.Response) (*DeleteIpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *bool   `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateJwtResponse parses an HTTP response from a CreateJwtWithResponse call
func ParseCreateJwtResponse(rsp *http.Response) (*CreateJwtResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJwtResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteJwtResponse parses an HTTP response from a DeleteJwtWithResponse call
func ParseDeleteJwtResponse(rsp *http.Response) (*DeleteJwtResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJwtResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateReferrerResponse parses an HTTP response from a CreateReferrerWithResponse call
func ParseCreateReferrerResponse(rsp *http.Response) (*CreateReferrerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateReferrerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteReferrerResponse parses an HTTP response from a DeleteReferrerWithResponse call
func ParseDeleteReferrerResponse(rsp *http.Response) (*DeleteReferrerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReferrerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *bool   `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAuthenticationTokenResponse parses an HTTP response from a CreateAuthenticationTokenWithResponse call
func ParseCreateAuthenticationTokenResponse(rsp *http.Response) (*CreateAuthenticationTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthenticationTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data  *bool   `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSecurityOptionsResponse parses an HTTP response from a GetSecurityOptionsWithResponse call
func ParseGetSecurityOptionsResponse(rsp *http.Response) (*GetSecurityOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecurityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateSecurityOptionsResponse parses an HTTP response from a UpdateSecurityOptionsWithResponse call
func ParseUpdateSecurityOptionsResponse(rsp *http.Response) (*UpdateSecurityOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSecurityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUsageResponse parses an HTTP response from a UsageWithResponse call
func ParseUsageResponse(rsp *http.Response) (*UsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				CreditsRemaining *int `json:"credits_remaining"`
				CreditsUsed      int  `json:"credits_used"`
				EndTime          int  `json:"end_time"`
				Limit            *int `json:"limit"`
				Overages         *int `json:"overages"`
				StartTime        int  `json:"start_time"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsageByChainResponse parses an HTTP response from a UsageByChainWithResponse call
func ParseUsageByChainResponse(rsp *http.Response) (*UsageByChainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageByChainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Chains    *[]ChainUsage `json:"chains,omitempty"`
				EndTime   *int          `json:"end_time,omitempty"`
				StartTime *int          `json:"start_time,omitempty"`
			} `json:"data"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsageByEndpointResponse parses an HTTP response from a UsageByEndpointWithResponse call
func ParseUsageByEndpointResponse(rsp *http.Response) (*UsageByEndpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageByEndpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				EndTime   *int             `json:"end_time,omitempty"`
				Endpoints *[]EndpointUsage `json:"endpoints,omitempty"`
				StartTime *int             `json:"start_time,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsageByMethodResponse parses an HTTP response from a UsageByMethodWithResponse call
func ParseUsageByMethodResponse(rsp *http.Response) (*UsageByMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsageByMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				EndTime   *int           `json:"end_time,omitempty"`
				Methods   *[]MethodUsage `json:"methods,omitempty"`
				StartTime *int           `json:"start_time,omitempty"`
			} `json:"data,omitempty"`
			Error *string `json:"error"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xca3PbuNX+Kxy+70c5khNn2/rbJpvd8XbTbpPddqYZDQcijyTEvC0AWtFo/N87uJEg",
	"CYigLrY6db5EJnCAg3Oe5+COXRgXWVnkkDMa3u5CGq8hQ+JnvEY45z9KUpRAGAbxGdOIQgoxi+oMbFtC",
	"eBsuiiIFlIePkzAHtinIvRRgkIkf/09gGd6G/zdtqpyq+qZKgMuq0hAhaMv/pmm1MmqhjOB8FT42OYvF",
	"V4gZzyo0iiqKVtBXPCaQYEajikJilIdzBisgQmuUgWdNkCdlgXNmqUZbJQEaE1wyXOThrfwciLZMQviG",
	"sjLlJQJbh5NuhZNwzVgZVSS1aDMJcWL9nKIFCIG8SlO04MUzUoGldG3snpIqoa9mhnCeA7OpuqFUazpQ",
	"8eMkJPBHhQm3/xfeDOWxsFHJaPp8j9mjpOAqRRmi930XyER/2+1zcIRLCwfsHpBZxxT+dcO8S793fHeg",
	"dhKW1SLFcXQP27FqZcAIji2GRQy1KF3/6JOpS+Pe32g1Vi2CGEQpzrCMVW3dUBwXlSSkA4eGck1J0WKr",
	"XOyQMqIaKRPP4svMNyP1ybjfKrAEQoB4A8kUGGN+CnFFMNu6CCfY6B/yrVy2AAWXB5SJS1tRXzfsgLI4",
	"SS2FFSJqUpc1PmpjDOMKl54Ztf4eUFU+9szOinvIvfLaENKqbJxtayzaIkSt1LgyhVy/wL3YljK+DKpz",
	"j6GPa1iydvVVwwMW/y4/A7YuEhotCKD7pNjk3maVkkp7i5ec3Y8xyvAwE84fChxb7IMyHtajpAK7DVR6",
	"ibDDSAucpjhfRQQQLZyWRsxlZNdwC+fQBqdNb3uRrVGXl3m6Vi+B4CKJIHcordIpQ8ShA2WIVdTaNFot",
	"WMFQahO0KdeCSN8QJF7jB/ALRMOYV5WNGKsbQGxr5oTuiClHibYZ2OYBPf8bcEMkiVJEWXTjRV4Fzwg5",
	"iqsIgTzeWhMzRO6BlSmKIWpUGh6ZOOFhMwLF+SqF6GVSVA+x2iNVv67QkOE2NUZbXvK1wDknZYZe/fmZ",
	"ofVnrp0iQon1HIRjIFwDSoCEuucIv12hEl/xHE2YK/FfQTRkAYgAiVDF1rwA+eePBck4F8Kf//Ub10jU",
	"xeOISG2K4VqHj1ytdUF5/s1m8+qPCsf3eZHAq7jIQt7xLAsB0SJnKGZNXAj/wXP+rUigF7KbpOB9kdMi",
	"heD7X++Cf8543ZgJdNQfHoBQKfUwk+NGyFGJw9vwzavZq+uQxxC2FqaaPsymqruaqg5RfF8B6+PyE5+k",
	"wQMEKaYsKJZBLSHqIIjnu0vC2/CuSSBAyyKnstjXs5luuQphqCxTHAvJ6VfVW0qguSeDnRGTobbX+EJ3",
	"/H7jNUIK4ofqLjZ7PqRVHAOlErZVliGyNaxKbWZlaEU5S95JH4VzLms6TfUGI5xWS3Sd9muTcHanmWp7",
	"OU33ehfrNMOsTqeJMOd21Y/A4nWA6iJV9q6f3uvPZ/CSly9ktLaMEUfY3ewCROVaen6wT6T5esbT3lBm",
	"q52huzEP6tRZRek9h/yCKftQl8ajK0EZMDE9/aL6oD8qINumCxK9ru5JkH3Ya5cslksKA6Lz58NGPSLj",
	"Axw7Ci4ELg2Fe+7VkGmcOucDb9Gld0HyXgyVAxTIIWldWJ+2IuOHJpm3CSh7VyTbI7zjns2PmQ63bcy9",
	"8HgWDO2DTndM/+wIkR6jAQpy2JiOteGjG1WmO5w8SrikwKAPnO/lLNUDOSqnAR1bhOFjuiZMiGF126OW",
	"kFHbzxExfKyk2zFgn4kzxlYkpx5W+LwuNs9ggosF/IGg5ma02NoR8hCL132n/V4mPOaJqW6wLIiH96TI",
	"2f13iohaz+A9bP54OG+UEQ8JK2qJ9IpP4K+aSb+VYD8Bo4HMHxDhNZm/66CfgH0UuT4hBr/oPBfCMrUE",
	"IiSaVQsgNBI99u0ufECpXK/VxGtlE8rXa67h69nrm6vZ9dXs+rfr17ez2e1s9mom/v07lAs7IbpevI7f",
	"JDdX8Hb53dUNeru4+kv85+TqT/Dd8i26WbyJXydiLs+APKCUNxHiIuff1Mo396TSO5KfeFfE1Qpvr2fN",
	"elcIOSd6Ej7OmwDA6f/4aCF1M1ZZ8uEuF5uEN7ObvuOJiqyQlWwbbNaQ11gLkgJokBcsgG/cfm1guhHT",
	"BWjAsRIosAwNkXiM75XqGCV1kHjR4aKBwC6EvMq4gRos4LxiEE7CBJnrV71tEtvWtrH70xk4SxBZl8pb",
	"S2tas6YaJTv3D2UjmKnRrtbeepS8eAIO068H4EA3StDQEvxx/oBSnAQGgF2MrenJmbksqjxxDkhtRBpg",
	"p29PMt2pDQ/jyMLAUPYH8d2P4DLvExB8Yi3E1rZn7MAiYVK1K9chTPipQZm0fBKoocSyStNteAhcVUFO",
	"DPYlXGDc7/ThrmLf0NIPSjLvfzmUTtEFnbQTMXfidH+mI+QkTDCVP+eTI8bHI9iiJkkmaZ6jc+H9956e",
	"JbpuNur0p9dNd/PmZN1NJTA/3N0oYLlHh8ME30/FQ3sbguOBFXAwVgOkgJxj5u7ZpZDTmnyUZwl7caBd",
	"Va333Q/C0yeIEe0K1kVFJkGCtpNgA3A/CbIiF+XbVnXl6Ym9FWou8nLVgHIS8pI5LkXRNkra43sUozSl",
	"UfEAJGI4g0mgWRpJmJpJhkhzmqcvYSTpyKhz8HKiDH1zND7TDhtuvF19Yy+kp3/N2k4DLDJmmrMJFiNf",
	"wHK7PkB7oZsyLTbbgsdHFRhcgaOz0lFWzLkqZUxZgyLfGzakxBMseJyik++c8Mhw/quRfj3pZi8dx5nU",
	"UWHn0eDh81cdpJiKzQ9dI/tkeG2oj3uHkuDTQP/2wTKXmoRvbcXd8V4+R2nwGcgDkOCDgLy9Lxy1HmKH",
	"sj6wMu2eYd6/v9RavWmOL9vXT36oDwRfNKQ7dypOt0t1+O5Ox7g9D3+uDyONce90Z/zlPZvO5fIczldd",
	"9QKr76XgeX1vnwq1W/dUO08ehjqBH9VZeW924tJByrvystcxy4vhoDDhcS6b7nB5FNEsbpT5z+NGO69E",
	"Gy5gF7N/bPr8G5XD3jkCIfpeizerv25cexU/by57f+Lct/ieIiBI6x/p7+nu64YdFRNsIJACZwKBPSrI",
	"ZlxEL3u0Y1o3ubzZWF/islPyU5N8wfO5MZciDySZrqPZpfJhm2HdU3h2utM/jyKf0+dS6pw+t9PQaNVL",
	"F73XX0egqLmS6R0cUMXWkDNlwEBenbQHiu9bWX9TOS/pdJ2Doo42Hm3o6U78fxRR7QaXImczsZ2iujEv",
	"/HS76XDMRMaFdPfZM507ULkHN3N+AqZV+Luq4CIPonXN4DqL9mWnbu5rQPL2WHYDjWzNqGgop5jIDGXC",
	"5XAe8w2Bobxr6lFpXDjUnw/ve/YxM3DYbfDojBWKA+gfPKQwGtpS8KnQfYpRqkFxlCSY/4FSc+NhiVIK",
	"3c0H4fux5wcm3XcsRkoLVI4XU+t7I6X0AsJIsdZ0Z6RsMxQ69lhGe/9Gu/g8hwLVZk5k6zReAuXJA+Wp",
	"zocMBlRXDPQbUYiXG6akjJ1jh7tlIN6SEDvvQUF4UJW/EYEgw5TifDUJ5FMELFD3YQN5kCLANKgoJAHK",
	"eVO5w3iieutBhGm2Bp2ZFyhPS0Pyqh+zxSMTA6dJPnNVA3XewHbGoWnL4K2/3kbmvnK1VZ7jQqD9tbva",
	"3H7PPgy/v1E38XYXLvVFfP6BMpSVoa1QeUjJq/7iAQhaAfV+pEK70VebTrRttXfSxkXd0vlTXWoeiBKC",
	"bwTlK3BenhRMDsTrLYJXtIQYLzG0hJuYINnUjwPTxfaqvsq49zaurpKjMFhsA/12hIW177bvVeILeQfI",
	"W99M978B7n6h6QDGHkasY0hymsNOpyJQF80+fDFfvxlFGff8RLLGfU3vhTidrwdAvfXwwLhTfk7GPT19",
	"no8ilhuT+1iirv6M4siKFFUJCa9NiTuY8lGnvvDk5Dyx3Wo45t3A/xmO2NDbY0rrwa8vu/a7V1/mHGr1",
	"O1pf5hwjVByPlPgWT32J567o7XSKStx55YrnV1XWr1v9rhxTf2juORsf1TMtlmzNNNJI1G/s2PKbpzFt",
	"6frQ8eP88T8BAAD//1GN6UuWXAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
